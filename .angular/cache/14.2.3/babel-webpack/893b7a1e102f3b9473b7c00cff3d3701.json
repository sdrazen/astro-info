{"ast":null,"code":"import _slicedToArray from \"C:/Users/Fritz7x64/Documents/Angular/astro-info/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _inherits from \"C:/Users/Fritz7x64/Documents/Angular/astro-info/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/Fritz7x64/Documents/Angular/astro-info/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _createForOfIteratorHelper from \"C:/Users/Fritz7x64/Documents/Angular/astro-info/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _classCallCheck from \"C:/Users/Fritz7x64/Documents/Angular/astro-info/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/Fritz7x64/Documents/Angular/astro-info/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport * as i0 from '@angular/core';\nimport { EventEmitter, PLATFORM_ID, Component, ChangeDetectionStrategy, ViewEncapsulation, Inject, Input, Output, Directive, ContentChildren, NgModule, Injectable } from '@angular/core';\nimport { isPlatformBrowser } from '@angular/common';\nimport { BehaviorSubject, Observable, Subject, combineLatest } from 'rxjs';\nimport { switchMap, take, map, takeUntil } from 'rxjs/operators';\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/** Manages event on a Google Maps object, ensuring that events are added only when necessary. */\n\nvar _c0 = [\"*\"];\n\nvar MapEventManager = /*#__PURE__*/function () {\n  function MapEventManager(_ngZone) {\n    _classCallCheck(this, MapEventManager);\n\n    this._ngZone = _ngZone;\n    /** Pending listeners that were added before the target was set. */\n\n    this._pending = [];\n    this._listeners = [];\n    this._targetStream = new BehaviorSubject(undefined);\n  }\n  /** Clears all currently-registered event listeners. */\n\n\n  _createClass(MapEventManager, [{\n    key: \"_clearListeners\",\n    value: function _clearListeners() {\n      var _iterator = _createForOfIteratorHelper(this._listeners),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var listener = _step.value;\n          listener.remove();\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      this._listeners = [];\n    }\n    /** Gets an observable that adds an event listener to the map when a consumer subscribes to it. */\n\n  }, {\n    key: \"getLazyEmitter\",\n    value: function getLazyEmitter(name) {\n      var _this = this;\n\n      return this._targetStream.pipe(switchMap(function (target) {\n        var observable = new Observable(function (observer) {\n          // If the target hasn't been initialized yet, cache the observer so it can be added later.\n          if (!target) {\n            _this._pending.push({\n              observable: observable,\n              observer: observer\n            });\n\n            return undefined;\n          }\n\n          var listener = target.addListener(name, function (event) {\n            _this._ngZone.run(function () {\n              return observer.next(event);\n            });\n          });\n\n          _this._listeners.push(listener);\n\n          return function () {\n            return listener.remove();\n          };\n        });\n        return observable;\n      }));\n    }\n    /** Sets the current target that the manager should bind events to. */\n\n  }, {\n    key: \"setTarget\",\n    value: function setTarget(target) {\n      var currentTarget = this._targetStream.value;\n\n      if (target === currentTarget) {\n        return;\n      } // Clear the listeners from the pre-existing target.\n\n\n      if (currentTarget) {\n        this._clearListeners();\n\n        this._pending = [];\n      }\n\n      this._targetStream.next(target); // Add the listeners that were bound before the map was initialized.\n\n\n      this._pending.forEach(function (subscriber) {\n        return subscriber.observable.subscribe(subscriber.observer);\n      });\n\n      this._pending = [];\n    }\n    /** Destroys the manager and clears the event listeners. */\n\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this._clearListeners();\n\n      this._pending = [];\n\n      this._targetStream.complete();\n    }\n  }]);\n\n  return MapEventManager;\n}(); /// <reference types=\"google.maps\" />\n\n/** default options set to the Googleplex */\n\n\nvar DEFAULT_OPTIONS = {\n  center: {\n    lat: 37.421995,\n    lng: -122.084092\n  },\n  zoom: 17,\n  // Note: the type conversion here isn't necessary for our CI, but it resolves a g3 failure.\n  mapTypeId: 'roadmap'\n};\n/** Arbitrary default height for the map element */\n\nvar DEFAULT_HEIGHT = '500px';\n/** Arbitrary default width for the map element */\n\nvar DEFAULT_WIDTH = '500px';\n/**\n * Angular component that renders a Google Map via the Google Maps JavaScript\n * API.\n * @see https://developers.google.com/maps/documentation/javascript/reference/\n */\n\nvar GoogleMap = /*#__PURE__*/(function () {\n  var GoogleMap = /*#__PURE__*/function () {\n    function GoogleMap(_elementRef, _ngZone, platformId) {\n      var _this2 = this;\n\n      _classCallCheck(this, GoogleMap);\n\n      this._elementRef = _elementRef;\n      this._ngZone = _ngZone;\n      this._eventManager = new MapEventManager(this._ngZone);\n      /** Height of the map. Set this to `null` if you'd like to control the height through CSS. */\n\n      this.height = DEFAULT_HEIGHT;\n      /** Width of the map. Set this to `null` if you'd like to control the width through CSS. */\n\n      this.width = DEFAULT_WIDTH;\n      this._options = DEFAULT_OPTIONS;\n      /** Event emitted when the map is initialized. */\n\n      this.mapInitialized = new EventEmitter();\n      /**\n       * See\n       * https://developers.google.com/maps/documentation/javascript/events#auth-errors\n       */\n\n      this.authFailure = new EventEmitter();\n      /**\n       * See\n       * https://developers.google.com/maps/documentation/javascript/reference/map#Map.bounds_changed\n       */\n\n      this.boundsChanged = this._eventManager.getLazyEmitter('bounds_changed');\n      /**\n       * See\n       * https://developers.google.com/maps/documentation/javascript/reference/map#Map.center_changed\n       */\n\n      this.centerChanged = this._eventManager.getLazyEmitter('center_changed');\n      /**\n       * See\n       * https://developers.google.com/maps/documentation/javascript/reference/map#Map.click\n       */\n\n      this.mapClick = this._eventManager.getLazyEmitter('click');\n      /**\n       * See\n       * https://developers.google.com/maps/documentation/javascript/reference/map#Map.dblclick\n       */\n\n      this.mapDblclick = this._eventManager.getLazyEmitter('dblclick');\n      /**\n       * See\n       * https://developers.google.com/maps/documentation/javascript/reference/map#Map.drag\n       */\n\n      this.mapDrag = this._eventManager.getLazyEmitter('drag');\n      /**\n       * See\n       * https://developers.google.com/maps/documentation/javascript/reference/map#Map.dragend\n       */\n\n      this.mapDragend = this._eventManager.getLazyEmitter('dragend');\n      /**\n       * See\n       * https://developers.google.com/maps/documentation/javascript/reference/map#Map.dragstart\n       */\n\n      this.mapDragstart = this._eventManager.getLazyEmitter('dragstart');\n      /**\n       * See\n       * https://developers.google.com/maps/documentation/javascript/reference/map#Map.heading_changed\n       */\n\n      this.headingChanged = this._eventManager.getLazyEmitter('heading_changed');\n      /**\n       * See\n       * https://developers.google.com/maps/documentation/javascript/reference/map#Map.idle\n       */\n\n      this.idle = this._eventManager.getLazyEmitter('idle');\n      /**\n       * See\n       * https://developers.google.com/maps/documentation/javascript/reference/map#Map.maptypeid_changed\n       */\n\n      this.maptypeidChanged = this._eventManager.getLazyEmitter('maptypeid_changed');\n      /**\n       * See\n       * https://developers.google.com/maps/documentation/javascript/reference/map#Map.mousemove\n       */\n\n      this.mapMousemove = this._eventManager.getLazyEmitter('mousemove');\n      /**\n       * See\n       * https://developers.google.com/maps/documentation/javascript/reference/map#Map.mouseout\n       */\n\n      this.mapMouseout = this._eventManager.getLazyEmitter('mouseout');\n      /**\n       * See\n       * https://developers.google.com/maps/documentation/javascript/reference/map#Map.mouseover\n       */\n\n      this.mapMouseover = this._eventManager.getLazyEmitter('mouseover');\n      /**\n       * See\n       * developers.google.com/maps/documentation/javascript/reference/map#Map.projection_changed\n       */\n\n      this.projectionChanged = this._eventManager.getLazyEmitter('projection_changed');\n      /**\n       * See\n       * https://developers.google.com/maps/documentation/javascript/reference/map#Map.rightclick\n       */\n\n      this.mapRightclick = this._eventManager.getLazyEmitter('rightclick');\n      /**\n       * See\n       * https://developers.google.com/maps/documentation/javascript/reference/map#Map.tilesloaded\n       */\n\n      this.tilesloaded = this._eventManager.getLazyEmitter('tilesloaded');\n      /**\n       * See\n       * https://developers.google.com/maps/documentation/javascript/reference/map#Map.tilt_changed\n       */\n\n      this.tiltChanged = this._eventManager.getLazyEmitter('tilt_changed');\n      /**\n       * See\n       * https://developers.google.com/maps/documentation/javascript/reference/map#Map.zoom_changed\n       */\n\n      this.zoomChanged = this._eventManager.getLazyEmitter('zoom_changed');\n      this._isBrowser = isPlatformBrowser(platformId);\n\n      if (this._isBrowser) {\n        var googleMapsWindow = window;\n\n        if (!googleMapsWindow.google && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n          throw Error('Namespace google not found, cannot construct embedded google ' + 'map. Please install the Google Maps JavaScript API: ' + 'https://developers.google.com/maps/documentation/javascript/' + 'tutorial#Loading_the_Maps_API');\n        }\n\n        this._existingAuthFailureCallback = googleMapsWindow.gm_authFailure;\n\n        googleMapsWindow.gm_authFailure = function () {\n          if (_this2._existingAuthFailureCallback) {\n            _this2._existingAuthFailureCallback();\n          }\n\n          _this2.authFailure.emit();\n        };\n      }\n    }\n\n    _createClass(GoogleMap, [{\n      key: \"center\",\n      set: function set(center) {\n        this._center = center;\n      }\n    }, {\n      key: \"zoom\",\n      set: function set(zoom) {\n        this._zoom = zoom;\n      }\n    }, {\n      key: \"options\",\n      set: function set(options) {\n        this._options = options || DEFAULT_OPTIONS;\n      }\n    }, {\n      key: \"ngOnChanges\",\n      value: function ngOnChanges(changes) {\n        if (changes['height'] || changes['width']) {\n          this._setSize();\n        }\n\n        var googleMap = this.googleMap;\n\n        if (googleMap) {\n          if (changes['options']) {\n            googleMap.setOptions(this._combineOptions());\n          }\n\n          if (changes['center'] && this._center) {\n            googleMap.setCenter(this._center);\n          } // Note that the zoom can be zero.\n\n\n          if (changes['zoom'] && this._zoom != null) {\n            googleMap.setZoom(this._zoom);\n          }\n\n          if (changes['mapTypeId'] && this.mapTypeId) {\n            googleMap.setMapTypeId(this.mapTypeId);\n          }\n        }\n      }\n    }, {\n      key: \"ngOnInit\",\n      value: function ngOnInit() {\n        var _this3 = this;\n\n        // It should be a noop during server-side rendering.\n        if (this._isBrowser) {\n          this._mapEl = this._elementRef.nativeElement.querySelector('.map-container');\n\n          this._setSize(); // Create the object outside the zone so its events don't trigger change detection.\n          // We'll bring it back in inside the `MapEventManager` only for the events that the\n          // user has subscribed to.\n\n\n          this._ngZone.runOutsideAngular(function () {\n            _this3.googleMap = new google.maps.Map(_this3._mapEl, _this3._combineOptions());\n          });\n\n          this._eventManager.setTarget(this.googleMap);\n\n          this.mapInitialized.emit(this.googleMap);\n        }\n      }\n    }, {\n      key: \"ngOnDestroy\",\n      value: function ngOnDestroy() {\n        this._eventManager.destroy();\n\n        if (this._isBrowser) {\n          var googleMapsWindow = window;\n          googleMapsWindow.gm_authFailure = this._existingAuthFailureCallback;\n        }\n      }\n      /**\n       * See\n       * https://developers.google.com/maps/documentation/javascript/reference/map#Map.fitBounds\n       */\n\n    }, {\n      key: \"fitBounds\",\n      value: function fitBounds(bounds, padding) {\n        this._assertInitialized();\n\n        this.googleMap.fitBounds(bounds, padding);\n      }\n      /**\n       * See\n       * https://developers.google.com/maps/documentation/javascript/reference/map#Map.panBy\n       */\n\n    }, {\n      key: \"panBy\",\n      value: function panBy(x, y) {\n        this._assertInitialized();\n\n        this.googleMap.panBy(x, y);\n      }\n      /**\n       * See\n       * https://developers.google.com/maps/documentation/javascript/reference/map#Map.panTo\n       */\n\n    }, {\n      key: \"panTo\",\n      value: function panTo(latLng) {\n        this._assertInitialized();\n\n        this.googleMap.panTo(latLng);\n      }\n      /**\n       * See\n       * https://developers.google.com/maps/documentation/javascript/reference/map#Map.panToBounds\n       */\n\n    }, {\n      key: \"panToBounds\",\n      value: function panToBounds(latLngBounds, padding) {\n        this._assertInitialized();\n\n        this.googleMap.panToBounds(latLngBounds, padding);\n      }\n      /**\n       * See\n       * https://developers.google.com/maps/documentation/javascript/reference/map#Map.getBounds\n       */\n\n    }, {\n      key: \"getBounds\",\n      value: function getBounds() {\n        this._assertInitialized();\n\n        return this.googleMap.getBounds() || null;\n      }\n      /**\n       * See\n       * https://developers.google.com/maps/documentation/javascript/reference/map#Map.getCenter\n       */\n\n    }, {\n      key: \"getCenter\",\n      value: function getCenter() {\n        this._assertInitialized();\n\n        return this.googleMap.getCenter();\n      }\n      /**\n       * See\n       * https://developers.google.com/maps/documentation/javascript/reference/map#Map.getClickableIcons\n       */\n\n    }, {\n      key: \"getClickableIcons\",\n      value: function getClickableIcons() {\n        this._assertInitialized();\n\n        return this.googleMap.getClickableIcons();\n      }\n      /**\n       * See\n       * https://developers.google.com/maps/documentation/javascript/reference/map#Map.getHeading\n       */\n\n    }, {\n      key: \"getHeading\",\n      value: function getHeading() {\n        this._assertInitialized();\n\n        return this.googleMap.getHeading();\n      }\n      /**\n       * See\n       * https://developers.google.com/maps/documentation/javascript/reference/map#Map.getMapTypeId\n       */\n\n    }, {\n      key: \"getMapTypeId\",\n      value: function getMapTypeId() {\n        this._assertInitialized();\n\n        return this.googleMap.getMapTypeId();\n      }\n      /**\n       * See\n       * https://developers.google.com/maps/documentation/javascript/reference/map#Map.getProjection\n       */\n\n    }, {\n      key: \"getProjection\",\n      value: function getProjection() {\n        this._assertInitialized();\n\n        return this.googleMap.getProjection() || null;\n      }\n      /**\n       * See\n       * https://developers.google.com/maps/documentation/javascript/reference/map#Map.getStreetView\n       */\n\n    }, {\n      key: \"getStreetView\",\n      value: function getStreetView() {\n        this._assertInitialized();\n\n        return this.googleMap.getStreetView();\n      }\n      /**\n       * See\n       * https://developers.google.com/maps/documentation/javascript/reference/map#Map.getTilt\n       */\n\n    }, {\n      key: \"getTilt\",\n      value: function getTilt() {\n        this._assertInitialized();\n\n        return this.googleMap.getTilt();\n      }\n      /**\n       * See\n       * https://developers.google.com/maps/documentation/javascript/reference/map#Map.getZoom\n       */\n\n    }, {\n      key: \"getZoom\",\n      value: function getZoom() {\n        this._assertInitialized();\n\n        return this.googleMap.getZoom();\n      }\n      /**\n       * See\n       * https://developers.google.com/maps/documentation/javascript/reference/map#Map.controls\n       */\n\n    }, {\n      key: \"controls\",\n      get: function get() {\n        this._assertInitialized();\n\n        return this.googleMap.controls;\n      }\n      /**\n       * See\n       * https://developers.google.com/maps/documentation/javascript/reference/map#Map.data\n       */\n\n    }, {\n      key: \"data\",\n      get: function get() {\n        this._assertInitialized();\n\n        return this.googleMap.data;\n      }\n      /**\n       * See\n       * https://developers.google.com/maps/documentation/javascript/reference/map#Map.mapTypes\n       */\n\n    }, {\n      key: \"mapTypes\",\n      get: function get() {\n        this._assertInitialized();\n\n        return this.googleMap.mapTypes;\n      }\n      /**\n       * See\n       * https://developers.google.com/maps/documentation/javascript/reference/map#Map.overlayMapTypes\n       */\n\n    }, {\n      key: \"overlayMapTypes\",\n      get: function get() {\n        this._assertInitialized();\n\n        return this.googleMap.overlayMapTypes;\n      }\n    }, {\n      key: \"_setSize\",\n      value: function _setSize() {\n        if (this._mapEl) {\n          var styles = this._mapEl.style;\n          styles.height = this.height === null ? '' : coerceCssPixelValue(this.height) || DEFAULT_HEIGHT;\n          styles.width = this.width === null ? '' : coerceCssPixelValue(this.width) || DEFAULT_WIDTH;\n        }\n      }\n      /** Combines the center and zoom and the other map options into a single object */\n\n    }, {\n      key: \"_combineOptions\",\n      value: function _combineOptions() {\n        var _a, _b;\n\n        var options = this._options || {};\n        return Object.assign(Object.assign({}, options), {\n          // It's important that we set **some** kind of `center` and `zoom`, otherwise\n          // Google Maps will render a blank rectangle which looks broken.\n          center: this._center || options.center || DEFAULT_OPTIONS.center,\n          zoom: (_b = (_a = this._zoom) !== null && _a !== void 0 ? _a : options.zoom) !== null && _b !== void 0 ? _b : DEFAULT_OPTIONS.zoom,\n          // Passing in an undefined `mapTypeId` seems to break tile loading\n          // so make sure that we have some kind of default (see #22082).\n          mapTypeId: this.mapTypeId || options.mapTypeId || DEFAULT_OPTIONS.mapTypeId\n        });\n      }\n      /** Asserts that the map has been initialized. */\n\n    }, {\n      key: \"_assertInitialized\",\n      value: function _assertInitialized() {\n        if (!this.googleMap && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n          throw Error('Cannot access Google Map information before the API has been initialized. ' + 'Please wait for the API to load before trying to interact with it.');\n        }\n      }\n    }]);\n\n    return GoogleMap;\n  }();\n\n  GoogleMap.ɵfac = function GoogleMap_Factory(t) {\n    return new (t || GoogleMap)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(PLATFORM_ID));\n  };\n\n  GoogleMap.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: GoogleMap,\n    selectors: [[\"google-map\"]],\n    inputs: {\n      height: \"height\",\n      width: \"width\",\n      mapTypeId: \"mapTypeId\",\n      center: \"center\",\n      zoom: \"zoom\",\n      options: \"options\"\n    },\n    outputs: {\n      mapInitialized: \"mapInitialized\",\n      authFailure: \"authFailure\",\n      boundsChanged: \"boundsChanged\",\n      centerChanged: \"centerChanged\",\n      mapClick: \"mapClick\",\n      mapDblclick: \"mapDblclick\",\n      mapDrag: \"mapDrag\",\n      mapDragend: \"mapDragend\",\n      mapDragstart: \"mapDragstart\",\n      headingChanged: \"headingChanged\",\n      idle: \"idle\",\n      maptypeidChanged: \"maptypeidChanged\",\n      mapMousemove: \"mapMousemove\",\n      mapMouseout: \"mapMouseout\",\n      mapMouseover: \"mapMouseover\",\n      projectionChanged: \"projectionChanged\",\n      mapRightclick: \"mapRightclick\",\n      tilesloaded: \"tilesloaded\",\n      tiltChanged: \"tiltChanged\",\n      zoomChanged: \"zoomChanged\"\n    },\n    exportAs: [\"googleMap\"],\n    features: [i0.ɵɵNgOnChangesFeature],\n    ngContentSelectors: _c0,\n    decls: 2,\n    vars: 0,\n    consts: [[1, \"map-container\"]],\n    template: function GoogleMap_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵelement(0, \"div\", 0);\n        i0.ɵɵprojection(1);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return GoogleMap;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar cssUnitsPattern = /([A-Za-z%]+)$/;\n/** Coerces a value to a CSS pixel value. */\n\nfunction coerceCssPixelValue(value) {\n  if (value == null) {\n    return '';\n  }\n\n  return cssUnitsPattern.test(value) ? value : \"\".concat(value, \"px\");\n} /// <reference types=\"google.maps\" />\n\n\nvar MapBaseLayer = /*#__PURE__*/(function () {\n  var MapBaseLayer = /*#__PURE__*/function () {\n    function MapBaseLayer(_map, _ngZone) {\n      _classCallCheck(this, MapBaseLayer);\n\n      this._map = _map;\n      this._ngZone = _ngZone;\n    }\n\n    _createClass(MapBaseLayer, [{\n      key: \"ngOnInit\",\n      value: function ngOnInit() {\n        var _this4 = this;\n\n        if (this._map._isBrowser) {\n          this._ngZone.runOutsideAngular(function () {\n            _this4._initializeObject();\n          });\n\n          this._assertInitialized();\n\n          this._setMap();\n        }\n      }\n    }, {\n      key: \"ngOnDestroy\",\n      value: function ngOnDestroy() {\n        this._unsetMap();\n      }\n    }, {\n      key: \"_assertInitialized\",\n      value: function _assertInitialized() {\n        if (!this._map.googleMap) {\n          throw Error('Cannot access Google Map information before the API has been initialized. ' + 'Please wait for the API to load before trying to interact with it.');\n        }\n      }\n    }, {\n      key: \"_initializeObject\",\n      value: function _initializeObject() {}\n    }, {\n      key: \"_setMap\",\n      value: function _setMap() {}\n    }, {\n      key: \"_unsetMap\",\n      value: function _unsetMap() {}\n    }]);\n\n    return MapBaseLayer;\n  }();\n\n  MapBaseLayer.ɵfac = function MapBaseLayer_Factory(t) {\n    return new (t || MapBaseLayer)(i0.ɵɵdirectiveInject(GoogleMap), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n\n  MapBaseLayer.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: MapBaseLayer,\n    selectors: [[\"map-base-layer\"]],\n    exportAs: [\"mapBaseLayer\"]\n  });\n  return MapBaseLayer;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})(); /// <reference types=\"google.maps\" />\n\n/**\n * Angular component that renders a Google Maps Bicycling Layer via the Google Maps JavaScript API.\n *\n * See developers.google.com/maps/documentation/javascript/reference/map#BicyclingLayer\n */\n\n\nvar MapBicyclingLayer = /*#__PURE__*/(function () {\n  var MapBicyclingLayer = /*#__PURE__*/function (_MapBaseLayer) {\n    _inherits(MapBicyclingLayer, _MapBaseLayer);\n\n    var _super = _createSuper(MapBicyclingLayer);\n\n    function MapBicyclingLayer() {\n      _classCallCheck(this, MapBicyclingLayer);\n\n      return _super.apply(this, arguments);\n    }\n\n    _createClass(MapBicyclingLayer, [{\n      key: \"_initializeObject\",\n      value: function _initializeObject() {\n        this.bicyclingLayer = new google.maps.BicyclingLayer();\n      }\n    }, {\n      key: \"_setMap\",\n      value: function _setMap() {\n        this._assertLayerInitialized();\n\n        this.bicyclingLayer.setMap(this._map.googleMap);\n      }\n    }, {\n      key: \"_unsetMap\",\n      value: function _unsetMap() {\n        if (this.bicyclingLayer) {\n          this.bicyclingLayer.setMap(null);\n        }\n      }\n    }, {\n      key: \"_assertLayerInitialized\",\n      value: function _assertLayerInitialized() {\n        if (!this.bicyclingLayer) {\n          throw Error('Cannot interact with a Google Map Bicycling Layer before it has been initialized. ' + 'Please wait for the Transit Layer to load before trying to interact with it.');\n        }\n      }\n    }]);\n\n    return MapBicyclingLayer;\n  }(MapBaseLayer);\n\n  MapBicyclingLayer.ɵfac = /* @__PURE__ */function () {\n    var ɵMapBicyclingLayer_BaseFactory;\n    return function MapBicyclingLayer_Factory(t) {\n      return (ɵMapBicyclingLayer_BaseFactory || (ɵMapBicyclingLayer_BaseFactory = i0.ɵɵgetInheritedFactory(MapBicyclingLayer)))(t || MapBicyclingLayer);\n    };\n  }();\n\n  MapBicyclingLayer.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: MapBicyclingLayer,\n    selectors: [[\"map-bicycling-layer\"]],\n    exportAs: [\"mapBicyclingLayer\"],\n    features: [i0.ɵɵInheritDefinitionFeature]\n  });\n  return MapBicyclingLayer;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})(); /// <reference types=\"google.maps\" />\n\n/**\n * Angular component that renders a Google Maps Circle via the Google Maps JavaScript API.\n * @see developers.google.com/maps/documentation/javascript/reference/polygon#Circle\n */\n\n\nvar MapCircle = /*#__PURE__*/(function () {\n  var MapCircle = /*#__PURE__*/function () {\n    function MapCircle(_map, _ngZone) {\n      _classCallCheck(this, MapCircle);\n\n      this._map = _map;\n      this._ngZone = _ngZone;\n      this._eventManager = new MapEventManager(this._ngZone);\n      this._options = new BehaviorSubject({});\n      this._center = new BehaviorSubject(undefined);\n      this._radius = new BehaviorSubject(undefined);\n      this._destroyed = new Subject();\n      /**\n       * @see\n       * developers.google.com/maps/documentation/javascript/reference/polygon#Circle.center_changed\n       */\n\n      this.centerChanged = this._eventManager.getLazyEmitter('center_changed');\n      /**\n       * @see\n       * developers.google.com/maps/documentation/javascript/reference/polygon#Circle.click\n       */\n\n      this.circleClick = this._eventManager.getLazyEmitter('click');\n      /**\n       * @see\n       * developers.google.com/maps/documentation/javascript/reference/polygon#Circle.dblclick\n       */\n\n      this.circleDblclick = this._eventManager.getLazyEmitter('dblclick');\n      /**\n       * @see\n       * developers.google.com/maps/documentation/javascript/reference/polygon#Circle.drag\n       */\n\n      this.circleDrag = this._eventManager.getLazyEmitter('drag');\n      /**\n       * @see\n       * developers.google.com/maps/documentation/javascript/reference/polygon#Circle.dragend\n       */\n\n      this.circleDragend = this._eventManager.getLazyEmitter('dragend');\n      /**\n       * @see\n       * developers.google.com/maps/documentation/javascript/reference/polygon#Circle.dragstart\n       */\n\n      this.circleDragstart = this._eventManager.getLazyEmitter('dragstart');\n      /**\n       * @see\n       * developers.google.com/maps/documentation/javascript/reference/polygon#Circle.mousedown\n       */\n\n      this.circleMousedown = this._eventManager.getLazyEmitter('mousedown');\n      /**\n       * @see\n       * developers.google.com/maps/documentation/javascript/reference/polygon#Circle.mousemove\n       */\n\n      this.circleMousemove = this._eventManager.getLazyEmitter('mousemove');\n      /**\n       * @see\n       * developers.google.com/maps/documentation/javascript/reference/polygon#Circle.mouseout\n       */\n\n      this.circleMouseout = this._eventManager.getLazyEmitter('mouseout');\n      /**\n       * @see\n       * developers.google.com/maps/documentation/javascript/reference/polygon#Circle.mouseover\n       */\n\n      this.circleMouseover = this._eventManager.getLazyEmitter('mouseover');\n      /**\n       * @see\n       * developers.google.com/maps/documentation/javascript/reference/polygon#Circle.mouseup\n       */\n\n      this.circleMouseup = this._eventManager.getLazyEmitter('mouseup');\n      /**\n       * @see\n       * developers.google.com/maps/documentation/javascript/reference/polygon#Circle.radius_changed\n       */\n\n      this.radiusChanged = this._eventManager.getLazyEmitter('radius_changed');\n      /**\n       * @see\n       * developers.google.com/maps/documentation/javascript/reference/polygon#Circle.rightclick\n       */\n\n      this.circleRightclick = this._eventManager.getLazyEmitter('rightclick');\n    }\n\n    _createClass(MapCircle, [{\n      key: \"options\",\n      set: function set(options) {\n        this._options.next(options || {});\n      }\n    }, {\n      key: \"center\",\n      set: function set(center) {\n        this._center.next(center);\n      }\n    }, {\n      key: \"radius\",\n      set: function set(radius) {\n        this._radius.next(radius);\n      }\n    }, {\n      key: \"ngOnInit\",\n      value: function ngOnInit() {\n        var _this5 = this;\n\n        if (this._map._isBrowser) {\n          this._combineOptions().pipe(take(1)).subscribe(function (options) {\n            // Create the object outside the zone so its events don't trigger change detection.\n            // We'll bring it back in inside the `MapEventManager` only for the events that the\n            // user has subscribed to.\n            _this5._ngZone.runOutsideAngular(function () {\n              _this5.circle = new google.maps.Circle(options);\n            });\n\n            _this5._assertInitialized();\n\n            _this5.circle.setMap(_this5._map.googleMap);\n\n            _this5._eventManager.setTarget(_this5.circle);\n          });\n\n          this._watchForOptionsChanges();\n\n          this._watchForCenterChanges();\n\n          this._watchForRadiusChanges();\n        }\n      }\n    }, {\n      key: \"ngOnDestroy\",\n      value: function ngOnDestroy() {\n        this._eventManager.destroy();\n\n        this._destroyed.next();\n\n        this._destroyed.complete();\n\n        if (this.circle) {\n          this.circle.setMap(null);\n        }\n      }\n      /**\n       * @see\n       * developers.google.com/maps/documentation/javascript/reference/polygon#Circle.getBounds\n       */\n\n    }, {\n      key: \"getBounds\",\n      value: function getBounds() {\n        this._assertInitialized();\n\n        return this.circle.getBounds();\n      }\n      /**\n       * @see\n       * developers.google.com/maps/documentation/javascript/reference/polygon#Circle.getCenter\n       */\n\n    }, {\n      key: \"getCenter\",\n      value: function getCenter() {\n        this._assertInitialized();\n\n        return this.circle.getCenter();\n      }\n      /**\n       * @see\n       * developers.google.com/maps/documentation/javascript/reference/polygon#Circle.getDraggable\n       */\n\n    }, {\n      key: \"getDraggable\",\n      value: function getDraggable() {\n        this._assertInitialized();\n\n        return this.circle.getDraggable();\n      }\n      /**\n       * @see\n       * developers.google.com/maps/documentation/javascript/reference/polygon#Circle.getEditable\n       */\n\n    }, {\n      key: \"getEditable\",\n      value: function getEditable() {\n        this._assertInitialized();\n\n        return this.circle.getEditable();\n      }\n      /**\n       * @see\n       * developers.google.com/maps/documentation/javascript/reference/polygon#Circle.getRadius\n       */\n\n    }, {\n      key: \"getRadius\",\n      value: function getRadius() {\n        this._assertInitialized();\n\n        return this.circle.getRadius();\n      }\n      /**\n       * @see\n       * developers.google.com/maps/documentation/javascript/reference/polygon#Circle.getVisible\n       */\n\n    }, {\n      key: \"getVisible\",\n      value: function getVisible() {\n        this._assertInitialized();\n\n        return this.circle.getVisible();\n      }\n    }, {\n      key: \"_combineOptions\",\n      value: function _combineOptions() {\n        return combineLatest([this._options, this._center, this._radius]).pipe(map(function (_ref) {\n          var _ref2 = _slicedToArray(_ref, 3),\n              options = _ref2[0],\n              center = _ref2[1],\n              radius = _ref2[2];\n\n          var combinedOptions = Object.assign(Object.assign({}, options), {\n            center: center || options.center,\n            radius: radius !== undefined ? radius : options.radius\n          });\n          return combinedOptions;\n        }));\n      }\n    }, {\n      key: \"_watchForOptionsChanges\",\n      value: function _watchForOptionsChanges() {\n        var _this6 = this;\n\n        this._options.pipe(takeUntil(this._destroyed)).subscribe(function (options) {\n          _this6._assertInitialized();\n\n          _this6.circle.setOptions(options);\n        });\n      }\n    }, {\n      key: \"_watchForCenterChanges\",\n      value: function _watchForCenterChanges() {\n        var _this7 = this;\n\n        this._center.pipe(takeUntil(this._destroyed)).subscribe(function (center) {\n          if (center) {\n            _this7._assertInitialized();\n\n            _this7.circle.setCenter(center);\n          }\n        });\n      }\n    }, {\n      key: \"_watchForRadiusChanges\",\n      value: function _watchForRadiusChanges() {\n        var _this8 = this;\n\n        this._radius.pipe(takeUntil(this._destroyed)).subscribe(function (radius) {\n          if (radius !== undefined) {\n            _this8._assertInitialized();\n\n            _this8.circle.setRadius(radius);\n          }\n        });\n      }\n    }, {\n      key: \"_assertInitialized\",\n      value: function _assertInitialized() {\n        if (typeof ngDevMode === 'undefined' || ngDevMode) {\n          if (!this._map.googleMap) {\n            throw Error('Cannot access Google Map information before the API has been initialized. ' + 'Please wait for the API to load before trying to interact with it.');\n          }\n\n          if (!this.circle) {\n            throw Error('Cannot interact with a Google Map Circle before it has been ' + 'initialized. Please wait for the Circle to load before trying to interact with it.');\n          }\n        }\n      }\n    }]);\n\n    return MapCircle;\n  }();\n\n  MapCircle.ɵfac = function MapCircle_Factory(t) {\n    return new (t || MapCircle)(i0.ɵɵdirectiveInject(GoogleMap), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n\n  MapCircle.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: MapCircle,\n    selectors: [[\"map-circle\"]],\n    inputs: {\n      options: \"options\",\n      center: \"center\",\n      radius: \"radius\"\n    },\n    outputs: {\n      centerChanged: \"centerChanged\",\n      circleClick: \"circleClick\",\n      circleDblclick: \"circleDblclick\",\n      circleDrag: \"circleDrag\",\n      circleDragend: \"circleDragend\",\n      circleDragstart: \"circleDragstart\",\n      circleMousedown: \"circleMousedown\",\n      circleMousemove: \"circleMousemove\",\n      circleMouseout: \"circleMouseout\",\n      circleMouseover: \"circleMouseover\",\n      circleMouseup: \"circleMouseup\",\n      radiusChanged: \"radiusChanged\",\n      circleRightclick: \"circleRightclick\"\n    },\n    exportAs: [\"mapCircle\"]\n  });\n  return MapCircle;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})(); /// <reference types=\"google.maps\" />\n\n/**\n * Angular component that renders a Google Maps Directions Renderer via the Google Maps\n * JavaScript API.\n *\n * See developers.google.com/maps/documentation/javascript/reference/directions#DirectionsRenderer\n */\n\n\nvar MapDirectionsRenderer = /*#__PURE__*/(function () {\n  var MapDirectionsRenderer = /*#__PURE__*/function () {\n    function MapDirectionsRenderer(_googleMap, _ngZone) {\n      _classCallCheck(this, MapDirectionsRenderer);\n\n      this._googleMap = _googleMap;\n      this._ngZone = _ngZone;\n      this._eventManager = new MapEventManager(this._ngZone);\n      /**\n       * See developers.google.com/maps/documentation/javascript/reference/directions\n       * #DirectionsRenderer.directions_changed\n       */\n\n      this.directionsChanged = this._eventManager.getLazyEmitter('directions_changed');\n    }\n    /**\n     * See developers.google.com/maps/documentation/javascript/reference/directions\n     * #DirectionsRendererOptions.directions\n     */\n\n\n    _createClass(MapDirectionsRenderer, [{\n      key: \"directions\",\n      set: function set(directions) {\n        this._directions = directions;\n      }\n      /**\n       * See developers.google.com/maps/documentation/javascript/reference/directions\n       * #DirectionsRendererOptions\n       */\n\n    }, {\n      key: \"options\",\n      set: function set(options) {\n        this._options = options;\n      }\n    }, {\n      key: \"ngOnInit\",\n      value: function ngOnInit() {\n        var _this9 = this;\n\n        if (this._googleMap._isBrowser) {\n          // Create the object outside the zone so its events don't trigger change detection.\n          // We'll bring it back in inside the `MapEventManager` only for the events that the\n          // user has subscribed to.\n          this._ngZone.runOutsideAngular(function () {\n            _this9.directionsRenderer = new google.maps.DirectionsRenderer(_this9._combineOptions());\n          });\n\n          this._assertInitialized();\n\n          this.directionsRenderer.setMap(this._googleMap.googleMap);\n\n          this._eventManager.setTarget(this.directionsRenderer);\n        }\n      }\n    }, {\n      key: \"ngOnChanges\",\n      value: function ngOnChanges(changes) {\n        if (this.directionsRenderer) {\n          if (changes['options']) {\n            this.directionsRenderer.setOptions(this._combineOptions());\n          }\n\n          if (changes['directions'] && this._directions !== undefined) {\n            this.directionsRenderer.setDirections(this._directions);\n          }\n        }\n      }\n    }, {\n      key: \"ngOnDestroy\",\n      value: function ngOnDestroy() {\n        this._eventManager.destroy();\n\n        if (this.directionsRenderer) {\n          this.directionsRenderer.setMap(null);\n        }\n      }\n      /**\n       * See developers.google.com/maps/documentation/javascript/reference/directions\n       * #DirectionsRenderer.getDirections\n       */\n\n    }, {\n      key: \"getDirections\",\n      value: function getDirections() {\n        this._assertInitialized();\n\n        return this.directionsRenderer.getDirections();\n      }\n      /**\n       * See developers.google.com/maps/documentation/javascript/reference/directions\n       * #DirectionsRenderer.getPanel\n       */\n\n    }, {\n      key: \"getPanel\",\n      value: function getPanel() {\n        this._assertInitialized();\n\n        return this.directionsRenderer.getPanel();\n      }\n      /**\n       * See developers.google.com/maps/documentation/javascript/reference/directions\n       * #DirectionsRenderer.getRouteIndex\n       */\n\n    }, {\n      key: \"getRouteIndex\",\n      value: function getRouteIndex() {\n        this._assertInitialized();\n\n        return this.directionsRenderer.getRouteIndex();\n      }\n    }, {\n      key: \"_combineOptions\",\n      value: function _combineOptions() {\n        var options = this._options || {};\n        return Object.assign(Object.assign({}, options), {\n          directions: this._directions || options.directions,\n          map: this._googleMap.googleMap\n        });\n      }\n    }, {\n      key: \"_assertInitialized\",\n      value: function _assertInitialized() {\n        if (typeof ngDevMode === 'undefined' || ngDevMode) {\n          if (!this._googleMap.googleMap) {\n            throw Error('Cannot access Google Map information before the API has been initialized. ' + 'Please wait for the API to load before trying to interact with it.');\n          }\n\n          if (!this.directionsRenderer) {\n            throw Error('Cannot interact with a Google Map Directions Renderer before it has been ' + 'initialized. Please wait for the Directions Renderer to load before trying ' + 'to interact with it.');\n          }\n        }\n      }\n    }]);\n\n    return MapDirectionsRenderer;\n  }();\n\n  MapDirectionsRenderer.ɵfac = function MapDirectionsRenderer_Factory(t) {\n    return new (t || MapDirectionsRenderer)(i0.ɵɵdirectiveInject(GoogleMap), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n\n  MapDirectionsRenderer.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: MapDirectionsRenderer,\n    selectors: [[\"map-directions-renderer\"]],\n    inputs: {\n      directions: \"directions\",\n      options: \"options\"\n    },\n    outputs: {\n      directionsChanged: \"directionsChanged\"\n    },\n    exportAs: [\"mapDirectionsRenderer\"],\n    features: [i0.ɵɵNgOnChangesFeature]\n  });\n  return MapDirectionsRenderer;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})(); /// <reference types=\"google.maps\" />\n\n/**\n * Angular component that renders a Google Maps Ground Overlay via the Google Maps JavaScript API.\n *\n * See developers.google.com/maps/documentation/javascript/reference/image-overlay#GroundOverlay\n */\n\n\nvar MapGroundOverlay = /*#__PURE__*/(function () {\n  var MapGroundOverlay = /*#__PURE__*/function () {\n    function MapGroundOverlay(_map, _ngZone) {\n      _classCallCheck(this, MapGroundOverlay);\n\n      this._map = _map;\n      this._ngZone = _ngZone;\n      this._eventManager = new MapEventManager(this._ngZone);\n      this._opacity = new BehaviorSubject(1);\n      this._url = new BehaviorSubject('');\n      this._bounds = new BehaviorSubject(undefined);\n      this._destroyed = new Subject();\n      /** Whether the overlay is clickable */\n\n      this.clickable = false;\n      /**\n       * See\n       * developers.google.com/maps/documentation/javascript/reference/image-overlay#GroundOverlay.click\n       */\n\n      this.mapClick = this._eventManager.getLazyEmitter('click');\n      /**\n       * See\n       * developers.google.com/maps/documentation/javascript/reference/image-overlay\n       * #GroundOverlay.dblclick\n       */\n\n      this.mapDblclick = this._eventManager.getLazyEmitter('dblclick');\n    }\n    /** URL of the image that will be shown in the overlay. */\n\n\n    _createClass(MapGroundOverlay, [{\n      key: \"url\",\n      set: function set(url) {\n        this._url.next(url);\n      }\n      /** Bounds for the overlay. */\n\n    }, {\n      key: \"bounds\",\n      get: function get() {\n        return this._bounds.value;\n      },\n      set: function set(bounds) {\n        this._bounds.next(bounds);\n      }\n      /** Opacity of the overlay. */\n\n    }, {\n      key: \"opacity\",\n      set: function set(opacity) {\n        this._opacity.next(opacity);\n      }\n    }, {\n      key: \"ngOnInit\",\n      value: function ngOnInit() {\n        var _this10 = this;\n\n        if (this._map._isBrowser) {\n          // The ground overlay setup is slightly different from the other Google Maps objects in that\n          // we have to recreate the `GroundOverlay` object whenever the bounds change, because\n          // Google Maps doesn't provide an API to update the bounds of an existing overlay.\n          this._bounds.pipe(takeUntil(this._destroyed)).subscribe(function (bounds) {\n            if (_this10.groundOverlay) {\n              _this10.groundOverlay.setMap(null);\n\n              _this10.groundOverlay = undefined;\n            } // Create the object outside the zone so its events don't trigger change detection.\n            // We'll bring it back in inside the `MapEventManager` only for the events that the\n            // user has subscribed to.\n\n\n            if (bounds) {\n              _this10._ngZone.runOutsideAngular(function () {\n                _this10.groundOverlay = new google.maps.GroundOverlay(_this10._url.getValue(), bounds, {\n                  clickable: _this10.clickable,\n                  opacity: _this10._opacity.value\n                });\n              });\n\n              _this10._assertInitialized();\n\n              _this10.groundOverlay.setMap(_this10._map.googleMap);\n\n              _this10._eventManager.setTarget(_this10.groundOverlay);\n            }\n          });\n\n          this._watchForOpacityChanges();\n\n          this._watchForUrlChanges();\n        }\n      }\n    }, {\n      key: \"ngOnDestroy\",\n      value: function ngOnDestroy() {\n        this._eventManager.destroy();\n\n        this._destroyed.next();\n\n        this._destroyed.complete();\n\n        if (this.groundOverlay) {\n          this.groundOverlay.setMap(null);\n        }\n      }\n      /**\n       * See\n       * developers.google.com/maps/documentation/javascript/reference/image-overlay\n       * #GroundOverlay.getBounds\n       */\n\n    }, {\n      key: \"getBounds\",\n      value: function getBounds() {\n        this._assertInitialized();\n\n        return this.groundOverlay.getBounds();\n      }\n      /**\n       * See\n       * developers.google.com/maps/documentation/javascript/reference/image-overlay\n       * #GroundOverlay.getOpacity\n       */\n\n    }, {\n      key: \"getOpacity\",\n      value: function getOpacity() {\n        this._assertInitialized();\n\n        return this.groundOverlay.getOpacity();\n      }\n      /**\n       * See\n       * developers.google.com/maps/documentation/javascript/reference/image-overlay\n       * #GroundOverlay.getUrl\n       */\n\n    }, {\n      key: \"getUrl\",\n      value: function getUrl() {\n        this._assertInitialized();\n\n        return this.groundOverlay.getUrl();\n      }\n    }, {\n      key: \"_watchForOpacityChanges\",\n      value: function _watchForOpacityChanges() {\n        var _this11 = this;\n\n        this._opacity.pipe(takeUntil(this._destroyed)).subscribe(function (opacity) {\n          if (opacity != null) {\n            _this11._assertInitialized();\n\n            _this11.groundOverlay.setOpacity(opacity);\n          }\n        });\n      }\n    }, {\n      key: \"_watchForUrlChanges\",\n      value: function _watchForUrlChanges() {\n        var _this12 = this;\n\n        this._url.pipe(takeUntil(this._destroyed)).subscribe(function (url) {\n          _this12._assertInitialized();\n\n          var overlay = _this12.groundOverlay;\n          overlay.set('url', url); // Google Maps only redraws the overlay if we re-set the map.\n\n          overlay.setMap(null);\n          overlay.setMap(_this12._map.googleMap);\n        });\n      }\n    }, {\n      key: \"_assertInitialized\",\n      value: function _assertInitialized() {\n        if (typeof ngDevMode === 'undefined' || ngDevMode) {\n          if (!this._map.googleMap) {\n            throw Error('Cannot access Google Map information before the API has been initialized. ' + 'Please wait for the API to load before trying to interact with it.');\n          }\n\n          if (!this.groundOverlay) {\n            throw Error('Cannot interact with a Google Map GroundOverlay before it has been initialized. ' + 'Please wait for the GroundOverlay to load before trying to interact with it.');\n          }\n        }\n      }\n    }]);\n\n    return MapGroundOverlay;\n  }();\n\n  MapGroundOverlay.ɵfac = function MapGroundOverlay_Factory(t) {\n    return new (t || MapGroundOverlay)(i0.ɵɵdirectiveInject(GoogleMap), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n\n  MapGroundOverlay.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: MapGroundOverlay,\n    selectors: [[\"map-ground-overlay\"]],\n    inputs: {\n      url: \"url\",\n      bounds: \"bounds\",\n      clickable: \"clickable\",\n      opacity: \"opacity\"\n    },\n    outputs: {\n      mapClick: \"mapClick\",\n      mapDblclick: \"mapDblclick\"\n    },\n    exportAs: [\"mapGroundOverlay\"]\n  });\n  return MapGroundOverlay;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})(); /// <reference types=\"google.maps\" />\n\n/**\n * Angular component that renders a Google Maps info window via the Google Maps JavaScript API.\n *\n * See developers.google.com/maps/documentation/javascript/reference/info-window\n */\n\n\nvar MapInfoWindow = /*#__PURE__*/(function () {\n  var MapInfoWindow = /*#__PURE__*/function () {\n    function MapInfoWindow(_googleMap, _elementRef, _ngZone) {\n      _classCallCheck(this, MapInfoWindow);\n\n      this._googleMap = _googleMap;\n      this._elementRef = _elementRef;\n      this._ngZone = _ngZone;\n      this._eventManager = new MapEventManager(this._ngZone);\n      this._options = new BehaviorSubject({});\n      this._position = new BehaviorSubject(undefined);\n      this._destroy = new Subject();\n      /**\n       * See\n       * developers.google.com/maps/documentation/javascript/reference/info-window#InfoWindow.closeclick\n       */\n\n      this.closeclick = this._eventManager.getLazyEmitter('closeclick');\n      /**\n       * See\n       * developers.google.com/maps/documentation/javascript/reference/info-window\n       * #InfoWindow.content_changed\n       */\n\n      this.contentChanged = this._eventManager.getLazyEmitter('content_changed');\n      /**\n       * See\n       * developers.google.com/maps/documentation/javascript/reference/info-window#InfoWindow.domready\n       */\n\n      this.domready = this._eventManager.getLazyEmitter('domready');\n      /**\n       * See\n       * developers.google.com/maps/documentation/javascript/reference/info-window\n       * #InfoWindow.position_changed\n       */\n\n      this.positionChanged = this._eventManager.getLazyEmitter('position_changed');\n      /**\n       * See\n       * developers.google.com/maps/documentation/javascript/reference/info-window\n       * #InfoWindow.zindex_changed\n       */\n\n      this.zindexChanged = this._eventManager.getLazyEmitter('zindex_changed');\n    }\n\n    _createClass(MapInfoWindow, [{\n      key: \"options\",\n      set: function set(options) {\n        this._options.next(options || {});\n      }\n    }, {\n      key: \"position\",\n      set: function set(position) {\n        this._position.next(position);\n      }\n    }, {\n      key: \"ngOnInit\",\n      value: function ngOnInit() {\n        var _this13 = this;\n\n        if (this._googleMap._isBrowser) {\n          var combinedOptionsChanges = this._combineOptions();\n\n          combinedOptionsChanges.pipe(take(1)).subscribe(function (options) {\n            // Create the object outside the zone so its events don't trigger change detection.\n            // We'll bring it back in inside the `MapEventManager` only for the events that the\n            // user has subscribed to.\n            _this13._ngZone.runOutsideAngular(function () {\n              _this13.infoWindow = new google.maps.InfoWindow(options);\n            });\n\n            _this13._eventManager.setTarget(_this13.infoWindow);\n          });\n\n          this._watchForOptionsChanges();\n\n          this._watchForPositionChanges();\n        }\n      }\n    }, {\n      key: \"ngOnDestroy\",\n      value: function ngOnDestroy() {\n        this._eventManager.destroy();\n\n        this._destroy.next();\n\n        this._destroy.complete(); // If no info window has been created on the server, we do not try closing it.\n        // On the server, an info window cannot be created and this would cause errors.\n\n\n        if (this.infoWindow) {\n          this.close();\n        }\n      }\n      /**\n       * See developers.google.com/maps/documentation/javascript/reference/info-window#InfoWindow.close\n       */\n\n    }, {\n      key: \"close\",\n      value: function close() {\n        this._assertInitialized();\n\n        this.infoWindow.close();\n      }\n      /**\n       * See\n       * developers.google.com/maps/documentation/javascript/reference/info-window#InfoWindow.getContent\n       */\n\n    }, {\n      key: \"getContent\",\n      value: function getContent() {\n        this._assertInitialized();\n\n        return this.infoWindow.getContent() || null;\n      }\n      /**\n       * See\n       * developers.google.com/maps/documentation/javascript/reference/info-window\n       * #InfoWindow.getPosition\n       */\n\n    }, {\n      key: \"getPosition\",\n      value: function getPosition() {\n        this._assertInitialized();\n\n        return this.infoWindow.getPosition() || null;\n      }\n      /**\n       * See\n       * developers.google.com/maps/documentation/javascript/reference/info-window#InfoWindow.getZIndex\n       */\n\n    }, {\n      key: \"getZIndex\",\n      value: function getZIndex() {\n        this._assertInitialized();\n\n        return this.infoWindow.getZIndex();\n      }\n      /**\n       * Opens the MapInfoWindow using the provided anchor. If the anchor is not set,\n       * then the position property of the options input is used instead.\n       */\n\n    }, {\n      key: \"open\",\n      value: function open(anchor, shouldFocus) {\n        this._assertInitialized();\n\n        var anchorObject = anchor ? anchor.getAnchor() : undefined; // Prevent the info window from initializing when trying to reopen on the same anchor.\n        // Note that when the window is opened for the first time, the anchor will always be\n        // undefined. If that's the case, we have to allow it to open in order to handle the\n        // case where the window doesn't have an anchor, but is placed at a particular position.\n\n        if (this.infoWindow.get('anchor') !== anchorObject || !anchorObject) {\n          this._elementRef.nativeElement.style.display = ''; // The config is cast to `any`, because the internal typings are out of date.\n\n          this.infoWindow.open({\n            map: this._googleMap.googleMap,\n            anchor: anchorObject,\n            shouldFocus: shouldFocus\n          });\n        }\n      }\n    }, {\n      key: \"_combineOptions\",\n      value: function _combineOptions() {\n        var _this14 = this;\n\n        return combineLatest([this._options, this._position]).pipe(map(function (_ref3) {\n          var _ref4 = _slicedToArray(_ref3, 2),\n              options = _ref4[0],\n              position = _ref4[1];\n\n          var combinedOptions = Object.assign(Object.assign({}, options), {\n            position: position || options.position,\n            content: _this14._elementRef.nativeElement\n          });\n          return combinedOptions;\n        }));\n      }\n    }, {\n      key: \"_watchForOptionsChanges\",\n      value: function _watchForOptionsChanges() {\n        var _this15 = this;\n\n        this._options.pipe(takeUntil(this._destroy)).subscribe(function (options) {\n          _this15._assertInitialized();\n\n          _this15.infoWindow.setOptions(options);\n        });\n      }\n    }, {\n      key: \"_watchForPositionChanges\",\n      value: function _watchForPositionChanges() {\n        var _this16 = this;\n\n        this._position.pipe(takeUntil(this._destroy)).subscribe(function (position) {\n          if (position) {\n            _this16._assertInitialized();\n\n            _this16.infoWindow.setPosition(position);\n          }\n        });\n      }\n    }, {\n      key: \"_assertInitialized\",\n      value: function _assertInitialized() {\n        if (typeof ngDevMode === 'undefined' || ngDevMode) {\n          if (!this._googleMap.googleMap) {\n            throw Error('Cannot access Google Map information before the API has been initialized. ' + 'Please wait for the API to load before trying to interact with it.');\n          }\n\n          if (!this.infoWindow) {\n            throw Error('Cannot interact with a Google Map Info Window before it has been ' + 'initialized. Please wait for the Info Window to load before trying to interact with ' + 'it.');\n          }\n        }\n      }\n    }]);\n\n    return MapInfoWindow;\n  }();\n\n  MapInfoWindow.ɵfac = function MapInfoWindow_Factory(t) {\n    return new (t || MapInfoWindow)(i0.ɵɵdirectiveInject(GoogleMap), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n\n  MapInfoWindow.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: MapInfoWindow,\n    selectors: [[\"map-info-window\"]],\n    hostAttrs: [2, \"display\", \"none\"],\n    inputs: {\n      options: \"options\",\n      position: \"position\"\n    },\n    outputs: {\n      closeclick: \"closeclick\",\n      contentChanged: \"contentChanged\",\n      domready: \"domready\",\n      positionChanged: \"positionChanged\",\n      zindexChanged: \"zindexChanged\"\n    },\n    exportAs: [\"mapInfoWindow\"]\n  });\n  return MapInfoWindow;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})(); /// <reference types=\"google.maps\" />\n\n/**\n * Angular component that renders a Google Maps KML Layer via the Google Maps JavaScript API.\n *\n * See developers.google.com/maps/documentation/javascript/reference/kml#KmlLayer\n */\n\n\nvar MapKmlLayer = /*#__PURE__*/(function () {\n  var MapKmlLayer = /*#__PURE__*/function () {\n    function MapKmlLayer(_map, _ngZone) {\n      _classCallCheck(this, MapKmlLayer);\n\n      this._map = _map;\n      this._ngZone = _ngZone;\n      this._eventManager = new MapEventManager(this._ngZone);\n      this._options = new BehaviorSubject({});\n      this._url = new BehaviorSubject('');\n      this._destroyed = new Subject();\n      /**\n       * See developers.google.com/maps/documentation/javascript/reference/kml#KmlLayer.click\n       */\n\n      this.kmlClick = this._eventManager.getLazyEmitter('click');\n      /**\n       * See\n       * developers.google.com/maps/documentation/javascript/reference/kml\n       * #KmlLayer.defaultviewport_changed\n       */\n\n      this.defaultviewportChanged = this._eventManager.getLazyEmitter('defaultviewport_changed');\n      /**\n       * See developers.google.com/maps/documentation/javascript/reference/kml#KmlLayer.status_changed\n       */\n\n      this.statusChanged = this._eventManager.getLazyEmitter('status_changed');\n    }\n\n    _createClass(MapKmlLayer, [{\n      key: \"options\",\n      set: function set(options) {\n        this._options.next(options || {});\n      }\n    }, {\n      key: \"url\",\n      set: function set(url) {\n        this._url.next(url);\n      }\n    }, {\n      key: \"ngOnInit\",\n      value: function ngOnInit() {\n        var _this17 = this;\n\n        if (this._map._isBrowser) {\n          this._combineOptions().pipe(take(1)).subscribe(function (options) {\n            // Create the object outside the zone so its events don't trigger change detection.\n            // We'll bring it back in inside the `MapEventManager` only for the events that the\n            // user has subscribed to.\n            _this17._ngZone.runOutsideAngular(function () {\n              return _this17.kmlLayer = new google.maps.KmlLayer(options);\n            });\n\n            _this17._assertInitialized();\n\n            _this17.kmlLayer.setMap(_this17._map.googleMap);\n\n            _this17._eventManager.setTarget(_this17.kmlLayer);\n          });\n\n          this._watchForOptionsChanges();\n\n          this._watchForUrlChanges();\n        }\n      }\n    }, {\n      key: \"ngOnDestroy\",\n      value: function ngOnDestroy() {\n        this._eventManager.destroy();\n\n        this._destroyed.next();\n\n        this._destroyed.complete();\n\n        if (this.kmlLayer) {\n          this.kmlLayer.setMap(null);\n        }\n      }\n      /**\n       * See\n       * developers.google.com/maps/documentation/javascript/reference/kml#KmlLayer.getDefaultViewport\n       */\n\n    }, {\n      key: \"getDefaultViewport\",\n      value: function getDefaultViewport() {\n        this._assertInitialized();\n\n        return this.kmlLayer.getDefaultViewport();\n      }\n      /**\n       * See developers.google.com/maps/documentation/javascript/reference/kml#KmlLayer.getMetadata\n       */\n\n    }, {\n      key: \"getMetadata\",\n      value: function getMetadata() {\n        this._assertInitialized();\n\n        return this.kmlLayer.getMetadata();\n      }\n      /**\n       * See developers.google.com/maps/documentation/javascript/reference/kml#KmlLayer.getStatus\n       */\n\n    }, {\n      key: \"getStatus\",\n      value: function getStatus() {\n        this._assertInitialized();\n\n        return this.kmlLayer.getStatus();\n      }\n      /**\n       * See developers.google.com/maps/documentation/javascript/reference/kml#KmlLayer.getUrl\n       */\n\n    }, {\n      key: \"getUrl\",\n      value: function getUrl() {\n        this._assertInitialized();\n\n        return this.kmlLayer.getUrl();\n      }\n      /**\n       * See developers.google.com/maps/documentation/javascript/reference/kml#KmlLayer.getZIndex\n       */\n\n    }, {\n      key: \"getZIndex\",\n      value: function getZIndex() {\n        this._assertInitialized();\n\n        return this.kmlLayer.getZIndex();\n      }\n    }, {\n      key: \"_combineOptions\",\n      value: function _combineOptions() {\n        return combineLatest([this._options, this._url]).pipe(map(function (_ref5) {\n          var _ref6 = _slicedToArray(_ref5, 2),\n              options = _ref6[0],\n              url = _ref6[1];\n\n          var combinedOptions = Object.assign(Object.assign({}, options), {\n            url: url || options.url\n          });\n          return combinedOptions;\n        }));\n      }\n    }, {\n      key: \"_watchForOptionsChanges\",\n      value: function _watchForOptionsChanges() {\n        var _this18 = this;\n\n        this._options.pipe(takeUntil(this._destroyed)).subscribe(function (options) {\n          if (_this18.kmlLayer) {\n            _this18._assertInitialized();\n\n            _this18.kmlLayer.setOptions(options);\n          }\n        });\n      }\n    }, {\n      key: \"_watchForUrlChanges\",\n      value: function _watchForUrlChanges() {\n        var _this19 = this;\n\n        this._url.pipe(takeUntil(this._destroyed)).subscribe(function (url) {\n          if (url && _this19.kmlLayer) {\n            _this19._assertInitialized();\n\n            _this19.kmlLayer.setUrl(url);\n          }\n        });\n      }\n    }, {\n      key: \"_assertInitialized\",\n      value: function _assertInitialized() {\n        if (typeof ngDevMode === 'undefined' || ngDevMode) {\n          if (!this._map.googleMap) {\n            throw Error('Cannot access Google Map information before the API has been initialized. ' + 'Please wait for the API to load before trying to interact with it.');\n          }\n\n          if (!this.kmlLayer) {\n            throw Error('Cannot interact with a Google Map KmlLayer before it has been ' + 'initialized. Please wait for the KmlLayer to load before trying to interact with it.');\n          }\n        }\n      }\n    }]);\n\n    return MapKmlLayer;\n  }();\n\n  MapKmlLayer.ɵfac = function MapKmlLayer_Factory(t) {\n    return new (t || MapKmlLayer)(i0.ɵɵdirectiveInject(GoogleMap), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n\n  MapKmlLayer.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: MapKmlLayer,\n    selectors: [[\"map-kml-layer\"]],\n    inputs: {\n      options: \"options\",\n      url: \"url\"\n    },\n    outputs: {\n      kmlClick: \"kmlClick\",\n      defaultviewportChanged: \"defaultviewportChanged\",\n      statusChanged: \"statusChanged\"\n    },\n    exportAs: [\"mapKmlLayer\"]\n  });\n  return MapKmlLayer;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})(); /// <reference types=\"google.maps\" />\n\n/**\n * Default options for the Google Maps marker component. Displays a marker\n * at the Googleplex.\n */\n\n\nvar DEFAULT_MARKER_OPTIONS = {\n  position: {\n    lat: 37.421995,\n    lng: -122.084092\n  }\n};\n/**\n * Angular component that renders a Google Maps marker via the Google Maps JavaScript API.\n *\n * See developers.google.com/maps/documentation/javascript/reference/marker\n */\n\nvar MapMarker = /*#__PURE__*/(function () {\n  var MapMarker = /*#__PURE__*/function () {\n    function MapMarker(_googleMap, _ngZone) {\n      _classCallCheck(this, MapMarker);\n\n      this._googleMap = _googleMap;\n      this._ngZone = _ngZone;\n      this._eventManager = new MapEventManager(this._ngZone);\n      /**\n       * See\n       * developers.google.com/maps/documentation/javascript/reference/marker#Marker.animation_changed\n       */\n\n      this.animationChanged = this._eventManager.getLazyEmitter('animation_changed');\n      /**\n       * See\n       * developers.google.com/maps/documentation/javascript/reference/marker#Marker.click\n       */\n\n      this.mapClick = this._eventManager.getLazyEmitter('click');\n      /**\n       * See\n       * developers.google.com/maps/documentation/javascript/reference/marker#Marker.clickable_changed\n       */\n\n      this.clickableChanged = this._eventManager.getLazyEmitter('clickable_changed');\n      /**\n       * See\n       * developers.google.com/maps/documentation/javascript/reference/marker#Marker.cursor_changed\n       */\n\n      this.cursorChanged = this._eventManager.getLazyEmitter('cursor_changed');\n      /**\n       * See\n       * developers.google.com/maps/documentation/javascript/reference/marker#Marker.dblclick\n       */\n\n      this.mapDblclick = this._eventManager.getLazyEmitter('dblclick');\n      /**\n       * See\n       * developers.google.com/maps/documentation/javascript/reference/marker#Marker.drag\n       */\n\n      this.mapDrag = this._eventManager.getLazyEmitter('drag');\n      /**\n       * See\n       * developers.google.com/maps/documentation/javascript/reference/marker#Marker.dragend\n       */\n\n      this.mapDragend = this._eventManager.getLazyEmitter('dragend');\n      /**\n       * See\n       * developers.google.com/maps/documentation/javascript/reference/marker#Marker.draggable_changed\n       */\n\n      this.draggableChanged = this._eventManager.getLazyEmitter('draggable_changed');\n      /**\n       * See\n       * developers.google.com/maps/documentation/javascript/reference/marker#Marker.dragstart\n       */\n\n      this.mapDragstart = this._eventManager.getLazyEmitter('dragstart');\n      /**\n       * See\n       * developers.google.com/maps/documentation/javascript/reference/marker#Marker.flat_changed\n       */\n\n      this.flatChanged = this._eventManager.getLazyEmitter('flat_changed');\n      /**\n       * See\n       * developers.google.com/maps/documentation/javascript/reference/marker#Marker.icon_changed\n       */\n\n      this.iconChanged = this._eventManager.getLazyEmitter('icon_changed');\n      /**\n       * See\n       * developers.google.com/maps/documentation/javascript/reference/marker#Marker.mousedown\n       */\n\n      this.mapMousedown = this._eventManager.getLazyEmitter('mousedown');\n      /**\n       * See\n       * developers.google.com/maps/documentation/javascript/reference/marker#Marker.mouseout\n       */\n\n      this.mapMouseout = this._eventManager.getLazyEmitter('mouseout');\n      /**\n       * See\n       * developers.google.com/maps/documentation/javascript/reference/marker#Marker.mouseover\n       */\n\n      this.mapMouseover = this._eventManager.getLazyEmitter('mouseover');\n      /**\n       * See\n       * developers.google.com/maps/documentation/javascript/reference/marker#Marker.mouseup\n       */\n\n      this.mapMouseup = this._eventManager.getLazyEmitter('mouseup');\n      /**\n       * See\n       * developers.google.com/maps/documentation/javascript/reference/marker#Marker.position_changed\n       */\n\n      this.positionChanged = this._eventManager.getLazyEmitter('position_changed');\n      /**\n       * See\n       * developers.google.com/maps/documentation/javascript/reference/marker#Marker.rightclick\n       */\n\n      this.mapRightclick = this._eventManager.getLazyEmitter('rightclick');\n      /**\n       * See\n       * developers.google.com/maps/documentation/javascript/reference/marker#Marker.shape_changed\n       */\n\n      this.shapeChanged = this._eventManager.getLazyEmitter('shape_changed');\n      /**\n       * See\n       * developers.google.com/maps/documentation/javascript/reference/marker#Marker.title_changed\n       */\n\n      this.titleChanged = this._eventManager.getLazyEmitter('title_changed');\n      /**\n       * See\n       * developers.google.com/maps/documentation/javascript/reference/marker#Marker.visible_changed\n       */\n\n      this.visibleChanged = this._eventManager.getLazyEmitter('visible_changed');\n      /**\n       * See\n       * developers.google.com/maps/documentation/javascript/reference/marker#Marker.zindex_changed\n       */\n\n      this.zindexChanged = this._eventManager.getLazyEmitter('zindex_changed');\n    }\n    /**\n     * Title of the marker.\n     * See: developers.google.com/maps/documentation/javascript/reference/marker#MarkerOptions.title\n     */\n\n\n    _createClass(MapMarker, [{\n      key: \"title\",\n      set: function set(title) {\n        this._title = title;\n      }\n      /**\n       * Position of the marker. See:\n       * developers.google.com/maps/documentation/javascript/reference/marker#MarkerOptions.position\n       */\n\n    }, {\n      key: \"position\",\n      set: function set(position) {\n        this._position = position;\n      }\n      /**\n       * Label for the marker.\n       * See: developers.google.com/maps/documentation/javascript/reference/marker#MarkerOptions.label\n       */\n\n    }, {\n      key: \"label\",\n      set: function set(label) {\n        this._label = label;\n      }\n      /**\n       * Whether the marker is clickable. See:\n       * developers.google.com/maps/documentation/javascript/reference/marker#MarkerOptions.clickable\n       */\n\n    }, {\n      key: \"clickable\",\n      set: function set(clickable) {\n        this._clickable = clickable;\n      }\n      /**\n       * Options used to configure the marker.\n       * See: developers.google.com/maps/documentation/javascript/reference/marker#MarkerOptions\n       */\n\n    }, {\n      key: \"options\",\n      set: function set(options) {\n        this._options = options;\n      }\n      /**\n       * Icon to be used for the marker.\n       * See: https://developers.google.com/maps/documentation/javascript/reference/marker#Icon\n       */\n\n    }, {\n      key: \"icon\",\n      set: function set(icon) {\n        this._icon = icon;\n      }\n      /**\n       * Whether the marker is visible.\n       * See: developers.google.com/maps/documentation/javascript/reference/marker#MarkerOptions.visible\n       */\n\n    }, {\n      key: \"visible\",\n      set: function set(value) {\n        this._visible = value;\n      }\n    }, {\n      key: \"ngOnInit\",\n      value: function ngOnInit() {\n        var _this20 = this;\n\n        if (this._googleMap._isBrowser) {\n          // Create the object outside the zone so its events don't trigger change detection.\n          // We'll bring it back in inside the `MapEventManager` only for the events that the\n          // user has subscribed to.\n          this._ngZone.runOutsideAngular(function () {\n            _this20.marker = new google.maps.Marker(_this20._combineOptions());\n          });\n\n          this._assertInitialized();\n\n          this.marker.setMap(this._googleMap.googleMap);\n\n          this._eventManager.setTarget(this.marker);\n        }\n      }\n    }, {\n      key: \"ngOnChanges\",\n      value: function ngOnChanges(changes) {\n        var marker = this.marker,\n            _title = this._title,\n            _position = this._position,\n            _label = this._label,\n            _clickable = this._clickable,\n            _icon = this._icon,\n            _visible = this._visible;\n\n        if (marker) {\n          if (changes['options']) {\n            marker.setOptions(this._combineOptions());\n          }\n\n          if (changes['title'] && _title !== undefined) {\n            marker.setTitle(_title);\n          }\n\n          if (changes['position'] && _position) {\n            marker.setPosition(_position);\n          }\n\n          if (changes['label'] && _label !== undefined) {\n            marker.setLabel(_label);\n          }\n\n          if (changes['clickable'] && _clickable !== undefined) {\n            marker.setClickable(_clickable);\n          }\n\n          if (changes['icon'] && _icon) {\n            marker.setIcon(_icon);\n          }\n\n          if (changes['visible'] && _visible !== undefined) {\n            marker.setVisible(_visible);\n          }\n        }\n      }\n    }, {\n      key: \"ngOnDestroy\",\n      value: function ngOnDestroy() {\n        this._eventManager.destroy();\n\n        if (this.marker) {\n          this.marker.setMap(null);\n        }\n      }\n      /**\n       * See\n       * developers.google.com/maps/documentation/javascript/reference/marker#Marker.getAnimation\n       */\n\n    }, {\n      key: \"getAnimation\",\n      value: function getAnimation() {\n        this._assertInitialized();\n\n        return this.marker.getAnimation() || null;\n      }\n      /**\n       * See\n       * developers.google.com/maps/documentation/javascript/reference/marker#Marker.getClickable\n       */\n\n    }, {\n      key: \"getClickable\",\n      value: function getClickable() {\n        this._assertInitialized();\n\n        return this.marker.getClickable();\n      }\n      /**\n       * See\n       * developers.google.com/maps/documentation/javascript/reference/marker#Marker.getCursor\n       */\n\n    }, {\n      key: \"getCursor\",\n      value: function getCursor() {\n        this._assertInitialized();\n\n        return this.marker.getCursor() || null;\n      }\n      /**\n       * See\n       * developers.google.com/maps/documentation/javascript/reference/marker#Marker.getDraggable\n       */\n\n    }, {\n      key: \"getDraggable\",\n      value: function getDraggable() {\n        this._assertInitialized();\n\n        return !!this.marker.getDraggable();\n      }\n      /**\n       * See\n       * developers.google.com/maps/documentation/javascript/reference/marker#Marker.getIcon\n       */\n\n    }, {\n      key: \"getIcon\",\n      value: function getIcon() {\n        this._assertInitialized();\n\n        return this.marker.getIcon() || null;\n      }\n      /**\n       * See\n       * developers.google.com/maps/documentation/javascript/reference/marker#Marker.getLabel\n       */\n\n    }, {\n      key: \"getLabel\",\n      value: function getLabel() {\n        this._assertInitialized();\n\n        return this.marker.getLabel() || null;\n      }\n      /**\n       * See\n       * developers.google.com/maps/documentation/javascript/reference/marker#Marker.getOpacity\n       */\n\n    }, {\n      key: \"getOpacity\",\n      value: function getOpacity() {\n        this._assertInitialized();\n\n        return this.marker.getOpacity() || null;\n      }\n      /**\n       * See\n       * developers.google.com/maps/documentation/javascript/reference/marker#Marker.getPosition\n       */\n\n    }, {\n      key: \"getPosition\",\n      value: function getPosition() {\n        this._assertInitialized();\n\n        return this.marker.getPosition() || null;\n      }\n      /**\n       * See\n       * developers.google.com/maps/documentation/javascript/reference/marker#Marker.getShape\n       */\n\n    }, {\n      key: \"getShape\",\n      value: function getShape() {\n        this._assertInitialized();\n\n        return this.marker.getShape() || null;\n      }\n      /**\n       * See\n       * developers.google.com/maps/documentation/javascript/reference/marker#Marker.getTitle\n       */\n\n    }, {\n      key: \"getTitle\",\n      value: function getTitle() {\n        this._assertInitialized();\n\n        return this.marker.getTitle() || null;\n      }\n      /**\n       * See\n       * developers.google.com/maps/documentation/javascript/reference/marker#Marker.getVisible\n       */\n\n    }, {\n      key: \"getVisible\",\n      value: function getVisible() {\n        this._assertInitialized();\n\n        return this.marker.getVisible();\n      }\n      /**\n       * See\n       * developers.google.com/maps/documentation/javascript/reference/marker#Marker.getZIndex\n       */\n\n    }, {\n      key: \"getZIndex\",\n      value: function getZIndex() {\n        this._assertInitialized();\n\n        return this.marker.getZIndex() || null;\n      }\n      /** Gets the anchor point that can be used to attach other Google Maps objects. */\n\n    }, {\n      key: \"getAnchor\",\n      value: function getAnchor() {\n        this._assertInitialized();\n\n        return this.marker;\n      }\n      /** Creates a combined options object using the passed-in options and the individual inputs. */\n\n    }, {\n      key: \"_combineOptions\",\n      value: function _combineOptions() {\n        var _a, _b;\n\n        var options = this._options || DEFAULT_MARKER_OPTIONS;\n        return Object.assign(Object.assign({}, options), {\n          title: this._title || options.title,\n          position: this._position || options.position,\n          label: this._label || options.label,\n          clickable: (_a = this._clickable) !== null && _a !== void 0 ? _a : options.clickable,\n          map: this._googleMap.googleMap,\n          icon: this._icon || options.icon,\n          visible: (_b = this._visible) !== null && _b !== void 0 ? _b : options.visible\n        });\n      }\n    }, {\n      key: \"_assertInitialized\",\n      value: function _assertInitialized() {\n        if (typeof ngDevMode === 'undefined' || ngDevMode) {\n          if (!this._googleMap.googleMap) {\n            throw Error('Cannot access Google Map information before the API has been initialized. ' + 'Please wait for the API to load before trying to interact with it.');\n          }\n\n          if (!this.marker) {\n            throw Error('Cannot interact with a Google Map Marker before it has been ' + 'initialized. Please wait for the Marker to load before trying to interact with it.');\n          }\n        }\n      }\n    }]);\n\n    return MapMarker;\n  }();\n\n  MapMarker.ɵfac = function MapMarker_Factory(t) {\n    return new (t || MapMarker)(i0.ɵɵdirectiveInject(GoogleMap), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n\n  MapMarker.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: MapMarker,\n    selectors: [[\"map-marker\"]],\n    inputs: {\n      title: \"title\",\n      position: \"position\",\n      label: \"label\",\n      clickable: \"clickable\",\n      options: \"options\",\n      icon: \"icon\",\n      visible: \"visible\"\n    },\n    outputs: {\n      animationChanged: \"animationChanged\",\n      mapClick: \"mapClick\",\n      clickableChanged: \"clickableChanged\",\n      cursorChanged: \"cursorChanged\",\n      mapDblclick: \"mapDblclick\",\n      mapDrag: \"mapDrag\",\n      mapDragend: \"mapDragend\",\n      draggableChanged: \"draggableChanged\",\n      mapDragstart: \"mapDragstart\",\n      flatChanged: \"flatChanged\",\n      iconChanged: \"iconChanged\",\n      mapMousedown: \"mapMousedown\",\n      mapMouseout: \"mapMouseout\",\n      mapMouseover: \"mapMouseover\",\n      mapMouseup: \"mapMouseup\",\n      positionChanged: \"positionChanged\",\n      mapRightclick: \"mapRightclick\",\n      shapeChanged: \"shapeChanged\",\n      titleChanged: \"titleChanged\",\n      visibleChanged: \"visibleChanged\",\n      zindexChanged: \"zindexChanged\"\n    },\n    exportAs: [\"mapMarker\"],\n    features: [i0.ɵɵNgOnChangesFeature]\n  });\n  return MapMarker;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})(); /// <reference types=\"google.maps\" />\n\n/** Default options for a clusterer. */\n\n\nvar DEFAULT_CLUSTERER_OPTIONS = {};\n/**\n * Angular component for implementing a Google Maps Marker Clusterer.\n *\n * See https://developers.google.com/maps/documentation/javascript/marker-clustering\n */\n\nvar MapMarkerClusterer = /*#__PURE__*/(function () {\n  var MapMarkerClusterer = /*#__PURE__*/function () {\n    function MapMarkerClusterer(_googleMap, _ngZone) {\n      _classCallCheck(this, MapMarkerClusterer);\n\n      this._googleMap = _googleMap;\n      this._ngZone = _ngZone;\n      this._currentMarkers = new Set();\n      this._eventManager = new MapEventManager(this._ngZone);\n      this._destroy = new Subject();\n\n      this.ariaLabelFn = function () {\n        return '';\n      };\n      /**\n       * See\n       * googlemaps.github.io/v3-utility-library/modules/\n       * _google_markerclustererplus.html#clusteringbegin\n       */\n\n\n      this.clusteringbegin = this._eventManager.getLazyEmitter('clusteringbegin');\n      /**\n       * See\n       * googlemaps.github.io/v3-utility-library/modules/_google_markerclustererplus.html#clusteringend\n       */\n\n      this.clusteringend = this._eventManager.getLazyEmitter('clusteringend');\n      /** Emits when a cluster has been clicked. */\n\n      this.clusterClick = this._eventManager.getLazyEmitter('click');\n      this._canInitialize = this._googleMap._isBrowser;\n    }\n\n    _createClass(MapMarkerClusterer, [{\n      key: \"averageCenter\",\n      set: function set(averageCenter) {\n        this._averageCenter = averageCenter;\n      }\n    }, {\n      key: \"batchSizeIE\",\n      set: function set(batchSizeIE) {\n        this._batchSizeIE = batchSizeIE;\n      }\n    }, {\n      key: \"calculator\",\n      set: function set(calculator) {\n        this._calculator = calculator;\n      }\n    }, {\n      key: \"clusterClass\",\n      set: function set(clusterClass) {\n        this._clusterClass = clusterClass;\n      }\n    }, {\n      key: \"enableRetinaIcons\",\n      set: function set(enableRetinaIcons) {\n        this._enableRetinaIcons = enableRetinaIcons;\n      }\n    }, {\n      key: \"gridSize\",\n      set: function set(gridSize) {\n        this._gridSize = gridSize;\n      }\n    }, {\n      key: \"ignoreHidden\",\n      set: function set(ignoreHidden) {\n        this._ignoreHidden = ignoreHidden;\n      }\n    }, {\n      key: \"imageExtension\",\n      set: function set(imageExtension) {\n        this._imageExtension = imageExtension;\n      }\n    }, {\n      key: \"imagePath\",\n      set: function set(imagePath) {\n        this._imagePath = imagePath;\n      }\n    }, {\n      key: \"imageSizes\",\n      set: function set(imageSizes) {\n        this._imageSizes = imageSizes;\n      }\n    }, {\n      key: \"maxZoom\",\n      set: function set(maxZoom) {\n        this._maxZoom = maxZoom;\n      }\n    }, {\n      key: \"minimumClusterSize\",\n      set: function set(minimumClusterSize) {\n        this._minimumClusterSize = minimumClusterSize;\n      }\n    }, {\n      key: \"styles\",\n      set: function set(styles) {\n        this._styles = styles;\n      }\n    }, {\n      key: \"title\",\n      set: function set(title) {\n        this._title = title;\n      }\n    }, {\n      key: \"zIndex\",\n      set: function set(zIndex) {\n        this._zIndex = zIndex;\n      }\n    }, {\n      key: \"zoomOnClick\",\n      set: function set(zoomOnClick) {\n        this._zoomOnClick = zoomOnClick;\n      }\n    }, {\n      key: \"options\",\n      set: function set(options) {\n        this._options = options;\n      }\n    }, {\n      key: \"ngOnInit\",\n      value: function ngOnInit() {\n        var _this21 = this;\n\n        if (this._canInitialize) {\n          if (typeof MarkerClusterer !== 'function' && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n            throw Error('MarkerClusterer class not found, cannot construct a marker cluster. ' + 'Please install the MarkerClustererPlus library: ' + 'https://github.com/googlemaps/js-markerclustererplus');\n          } // Create the object outside the zone so its events don't trigger change detection.\n          // We'll bring it back in inside the `MapEventManager` only for the events that the\n          // user has subscribed to.\n\n\n          this._ngZone.runOutsideAngular(function () {\n            _this21.markerClusterer = new MarkerClusterer(_this21._googleMap.googleMap, [], _this21._combineOptions());\n          });\n\n          this._assertInitialized();\n\n          this._eventManager.setTarget(this.markerClusterer);\n        }\n      }\n    }, {\n      key: \"ngAfterContentInit\",\n      value: function ngAfterContentInit() {\n        if (this._canInitialize) {\n          this._watchForMarkerChanges();\n        }\n      }\n    }, {\n      key: \"ngOnChanges\",\n      value: function ngOnChanges(changes) {\n        var clusterer = this.markerClusterer,\n            ariaLabelFn = this.ariaLabelFn,\n            _averageCenter = this._averageCenter,\n            _batchSizeIE = this._batchSizeIE,\n            _calculator = this._calculator,\n            _styles = this._styles,\n            _clusterClass = this._clusterClass,\n            _enableRetinaIcons = this._enableRetinaIcons,\n            _gridSize = this._gridSize,\n            _ignoreHidden = this._ignoreHidden,\n            _imageExtension = this._imageExtension,\n            _imagePath = this._imagePath,\n            _imageSizes = this._imageSizes,\n            _maxZoom = this._maxZoom,\n            _minimumClusterSize = this._minimumClusterSize,\n            _title = this._title,\n            _zIndex = this._zIndex,\n            _zoomOnClick = this._zoomOnClick;\n\n        if (clusterer) {\n          if (changes['options']) {\n            clusterer.setOptions(this._combineOptions());\n          }\n\n          if (changes['ariaLabelFn']) {\n            clusterer.ariaLabelFn = ariaLabelFn;\n          }\n\n          if (changes['averageCenter'] && _averageCenter !== undefined) {\n            clusterer.setAverageCenter(_averageCenter);\n          }\n\n          if (changes['batchSizeIE'] && _batchSizeIE !== undefined) {\n            clusterer.setBatchSizeIE(_batchSizeIE);\n          }\n\n          if (changes['calculator'] && !!_calculator) {\n            clusterer.setCalculator(_calculator);\n          }\n\n          if (changes['clusterClass'] && _clusterClass !== undefined) {\n            clusterer.setClusterClass(_clusterClass);\n          }\n\n          if (changes['enableRetinaIcons'] && _enableRetinaIcons !== undefined) {\n            clusterer.setEnableRetinaIcons(_enableRetinaIcons);\n          }\n\n          if (changes['gridSize'] && _gridSize !== undefined) {\n            clusterer.setGridSize(_gridSize);\n          }\n\n          if (changes['ignoreHidden'] && _ignoreHidden !== undefined) {\n            clusterer.setIgnoreHidden(_ignoreHidden);\n          }\n\n          if (changes['imageExtension'] && _imageExtension !== undefined) {\n            clusterer.setImageExtension(_imageExtension);\n          }\n\n          if (changes['imagePath'] && _imagePath !== undefined) {\n            clusterer.setImagePath(_imagePath);\n          }\n\n          if (changes['imageSizes'] && _imageSizes) {\n            clusterer.setImageSizes(_imageSizes);\n          }\n\n          if (changes['maxZoom'] && _maxZoom !== undefined) {\n            clusterer.setMaxZoom(_maxZoom);\n          }\n\n          if (changes['minimumClusterSize'] && _minimumClusterSize !== undefined) {\n            clusterer.setMinimumClusterSize(_minimumClusterSize);\n          }\n\n          if (changes['styles'] && _styles) {\n            clusterer.setStyles(_styles);\n          }\n\n          if (changes['title'] && _title !== undefined) {\n            clusterer.setTitle(_title);\n          }\n\n          if (changes['zIndex'] && _zIndex !== undefined) {\n            clusterer.setZIndex(_zIndex);\n          }\n\n          if (changes['zoomOnClick'] && _zoomOnClick !== undefined) {\n            clusterer.setZoomOnClick(_zoomOnClick);\n          }\n        }\n      }\n    }, {\n      key: \"ngOnDestroy\",\n      value: function ngOnDestroy() {\n        this._destroy.next();\n\n        this._destroy.complete();\n\n        this._eventManager.destroy();\n\n        if (this.markerClusterer) {\n          this.markerClusterer.setMap(null);\n        }\n      }\n    }, {\n      key: \"fitMapToMarkers\",\n      value: function fitMapToMarkers(padding) {\n        this._assertInitialized();\n\n        this.markerClusterer.fitMapToMarkers(padding);\n      }\n    }, {\n      key: \"getAverageCenter\",\n      value: function getAverageCenter() {\n        this._assertInitialized();\n\n        return this.markerClusterer.getAverageCenter();\n      }\n    }, {\n      key: \"getBatchSizeIE\",\n      value: function getBatchSizeIE() {\n        this._assertInitialized();\n\n        return this.markerClusterer.getBatchSizeIE();\n      }\n    }, {\n      key: \"getCalculator\",\n      value: function getCalculator() {\n        this._assertInitialized();\n\n        return this.markerClusterer.getCalculator();\n      }\n    }, {\n      key: \"getClusterClass\",\n      value: function getClusterClass() {\n        this._assertInitialized();\n\n        return this.markerClusterer.getClusterClass();\n      }\n    }, {\n      key: \"getClusters\",\n      value: function getClusters() {\n        this._assertInitialized();\n\n        return this.markerClusterer.getClusters();\n      }\n    }, {\n      key: \"getEnableRetinaIcons\",\n      value: function getEnableRetinaIcons() {\n        this._assertInitialized();\n\n        return this.markerClusterer.getEnableRetinaIcons();\n      }\n    }, {\n      key: \"getGridSize\",\n      value: function getGridSize() {\n        this._assertInitialized();\n\n        return this.markerClusterer.getGridSize();\n      }\n    }, {\n      key: \"getIgnoreHidden\",\n      value: function getIgnoreHidden() {\n        this._assertInitialized();\n\n        return this.markerClusterer.getIgnoreHidden();\n      }\n    }, {\n      key: \"getImageExtension\",\n      value: function getImageExtension() {\n        this._assertInitialized();\n\n        return this.markerClusterer.getImageExtension();\n      }\n    }, {\n      key: \"getImagePath\",\n      value: function getImagePath() {\n        this._assertInitialized();\n\n        return this.markerClusterer.getImagePath();\n      }\n    }, {\n      key: \"getImageSizes\",\n      value: function getImageSizes() {\n        this._assertInitialized();\n\n        return this.markerClusterer.getImageSizes();\n      }\n    }, {\n      key: \"getMaxZoom\",\n      value: function getMaxZoom() {\n        this._assertInitialized();\n\n        return this.markerClusterer.getMaxZoom();\n      }\n    }, {\n      key: \"getMinimumClusterSize\",\n      value: function getMinimumClusterSize() {\n        this._assertInitialized();\n\n        return this.markerClusterer.getMinimumClusterSize();\n      }\n    }, {\n      key: \"getStyles\",\n      value: function getStyles() {\n        this._assertInitialized();\n\n        return this.markerClusterer.getStyles();\n      }\n    }, {\n      key: \"getTitle\",\n      value: function getTitle() {\n        this._assertInitialized();\n\n        return this.markerClusterer.getTitle();\n      }\n    }, {\n      key: \"getTotalClusters\",\n      value: function getTotalClusters() {\n        this._assertInitialized();\n\n        return this.markerClusterer.getTotalClusters();\n      }\n    }, {\n      key: \"getTotalMarkers\",\n      value: function getTotalMarkers() {\n        this._assertInitialized();\n\n        return this.markerClusterer.getTotalMarkers();\n      }\n    }, {\n      key: \"getZIndex\",\n      value: function getZIndex() {\n        this._assertInitialized();\n\n        return this.markerClusterer.getZIndex();\n      }\n    }, {\n      key: \"getZoomOnClick\",\n      value: function getZoomOnClick() {\n        this._assertInitialized();\n\n        return this.markerClusterer.getZoomOnClick();\n      }\n    }, {\n      key: \"_combineOptions\",\n      value: function _combineOptions() {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t;\n\n        var options = this._options || DEFAULT_CLUSTERER_OPTIONS;\n        return Object.assign(Object.assign({}, options), {\n          ariaLabelFn: (_a = this.ariaLabelFn) !== null && _a !== void 0 ? _a : options.ariaLabelFn,\n          averageCenter: (_b = this._averageCenter) !== null && _b !== void 0 ? _b : options.averageCenter,\n          batchSize: (_c = this.batchSize) !== null && _c !== void 0 ? _c : options.batchSize,\n          batchSizeIE: (_d = this._batchSizeIE) !== null && _d !== void 0 ? _d : options.batchSizeIE,\n          calculator: (_e = this._calculator) !== null && _e !== void 0 ? _e : options.calculator,\n          clusterClass: (_f = this._clusterClass) !== null && _f !== void 0 ? _f : options.clusterClass,\n          enableRetinaIcons: (_g = this._enableRetinaIcons) !== null && _g !== void 0 ? _g : options.enableRetinaIcons,\n          gridSize: (_h = this._gridSize) !== null && _h !== void 0 ? _h : options.gridSize,\n          ignoreHidden: (_j = this._ignoreHidden) !== null && _j !== void 0 ? _j : options.ignoreHidden,\n          imageExtension: (_k = this._imageExtension) !== null && _k !== void 0 ? _k : options.imageExtension,\n          imagePath: (_l = this._imagePath) !== null && _l !== void 0 ? _l : options.imagePath,\n          imageSizes: (_m = this._imageSizes) !== null && _m !== void 0 ? _m : options.imageSizes,\n          maxZoom: (_o = this._maxZoom) !== null && _o !== void 0 ? _o : options.maxZoom,\n          minimumClusterSize: (_p = this._minimumClusterSize) !== null && _p !== void 0 ? _p : options.minimumClusterSize,\n          styles: (_q = this._styles) !== null && _q !== void 0 ? _q : options.styles,\n          title: (_r = this._title) !== null && _r !== void 0 ? _r : options.title,\n          zIndex: (_s = this._zIndex) !== null && _s !== void 0 ? _s : options.zIndex,\n          zoomOnClick: (_t = this._zoomOnClick) !== null && _t !== void 0 ? _t : options.zoomOnClick\n        });\n      }\n    }, {\n      key: \"_watchForMarkerChanges\",\n      value: function _watchForMarkerChanges() {\n        var _this22 = this;\n\n        this._assertInitialized();\n\n        var initialMarkers = [];\n\n        var _iterator2 = _createForOfIteratorHelper(this._getInternalMarkers(this._markers.toArray())),\n            _step2;\n\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var marker = _step2.value;\n\n            this._currentMarkers.add(marker);\n\n            initialMarkers.push(marker);\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n\n        this.markerClusterer.addMarkers(initialMarkers);\n\n        this._markers.changes.pipe(takeUntil(this._destroy)).subscribe(function (markerComponents) {\n          _this22._assertInitialized();\n\n          var newMarkers = new Set(_this22._getInternalMarkers(markerComponents));\n          var markersToAdd = [];\n          var markersToRemove = [];\n\n          for (var _i = 0, _Array$from = Array.from(newMarkers); _i < _Array$from.length; _i++) {\n            var marker = _Array$from[_i];\n\n            if (!_this22._currentMarkers.has(marker)) {\n              _this22._currentMarkers.add(marker);\n\n              markersToAdd.push(marker);\n            }\n          }\n\n          for (var _i2 = 0, _Array$from2 = Array.from(_this22._currentMarkers); _i2 < _Array$from2.length; _i2++) {\n            var _marker = _Array$from2[_i2];\n\n            if (!newMarkers.has(_marker)) {\n              markersToRemove.push(_marker);\n            }\n          }\n\n          _this22.markerClusterer.addMarkers(markersToAdd, true);\n\n          _this22.markerClusterer.removeMarkers(markersToRemove, true);\n\n          _this22.markerClusterer.repaint();\n\n          for (var _i3 = 0, _markersToRemove = markersToRemove; _i3 < _markersToRemove.length; _i3++) {\n            var _marker2 = _markersToRemove[_i3];\n\n            _this22._currentMarkers.delete(_marker2);\n          }\n        });\n      }\n    }, {\n      key: \"_getInternalMarkers\",\n      value: function _getInternalMarkers(markers) {\n        return markers.filter(function (markerComponent) {\n          return !!markerComponent.marker;\n        }).map(function (markerComponent) {\n          return markerComponent.marker;\n        });\n      }\n    }, {\n      key: \"_assertInitialized\",\n      value: function _assertInitialized() {\n        if (typeof ngDevMode === 'undefined' || ngDevMode) {\n          if (!this._googleMap.googleMap) {\n            throw Error('Cannot access Google Map information before the API has been initialized. ' + 'Please wait for the API to load before trying to interact with it.');\n          }\n\n          if (!this.markerClusterer) {\n            throw Error('Cannot interact with a MarkerClusterer before it has been initialized. ' + 'Please wait for the MarkerClusterer to load before trying to interact with it.');\n          }\n        }\n      }\n    }]);\n\n    return MapMarkerClusterer;\n  }();\n\n  MapMarkerClusterer.ɵfac = function MapMarkerClusterer_Factory(t) {\n    return new (t || MapMarkerClusterer)(i0.ɵɵdirectiveInject(GoogleMap), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n\n  MapMarkerClusterer.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: MapMarkerClusterer,\n    selectors: [[\"map-marker-clusterer\"]],\n    contentQueries: function MapMarkerClusterer_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, MapMarker, 5);\n      }\n\n      if (rf & 2) {\n        var _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._markers = _t);\n      }\n    },\n    inputs: {\n      ariaLabelFn: \"ariaLabelFn\",\n      averageCenter: \"averageCenter\",\n      batchSize: \"batchSize\",\n      batchSizeIE: \"batchSizeIE\",\n      calculator: \"calculator\",\n      clusterClass: \"clusterClass\",\n      enableRetinaIcons: \"enableRetinaIcons\",\n      gridSize: \"gridSize\",\n      ignoreHidden: \"ignoreHidden\",\n      imageExtension: \"imageExtension\",\n      imagePath: \"imagePath\",\n      imageSizes: \"imageSizes\",\n      maxZoom: \"maxZoom\",\n      minimumClusterSize: \"minimumClusterSize\",\n      styles: \"styles\",\n      title: \"title\",\n      zIndex: \"zIndex\",\n      zoomOnClick: \"zoomOnClick\",\n      options: \"options\"\n    },\n    outputs: {\n      clusteringbegin: \"clusteringbegin\",\n      clusteringend: \"clusteringend\",\n      clusterClick: \"clusterClick\"\n    },\n    exportAs: [\"mapMarkerClusterer\"],\n    features: [i0.ɵɵNgOnChangesFeature],\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function MapMarkerClusterer_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return MapMarkerClusterer;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})(); /// <reference types=\"google.maps\" />\n\n/**\n * Angular component that renders a Google Maps Polygon via the Google Maps JavaScript API.\n *\n * See developers.google.com/maps/documentation/javascript/reference/polygon#Polygon\n */\n\n\nvar MapPolygon = /*#__PURE__*/(function () {\n  var MapPolygon = /*#__PURE__*/function () {\n    function MapPolygon(_map, _ngZone) {\n      _classCallCheck(this, MapPolygon);\n\n      this._map = _map;\n      this._ngZone = _ngZone;\n      this._eventManager = new MapEventManager(this._ngZone);\n      this._options = new BehaviorSubject({});\n      this._paths = new BehaviorSubject(undefined);\n      this._destroyed = new Subject();\n      /**\n       * See developers.google.com/maps/documentation/javascript/reference/polygon#Polygon.click\n       */\n\n      this.polygonClick = this._eventManager.getLazyEmitter('click');\n      /**\n       * See developers.google.com/maps/documentation/javascript/reference/polygon#Polygon.dblclick\n       */\n\n      this.polygonDblclick = this._eventManager.getLazyEmitter('dblclick');\n      /**\n       * See developers.google.com/maps/documentation/javascript/reference/polygon#Polygon.drag\n       */\n\n      this.polygonDrag = this._eventManager.getLazyEmitter('drag');\n      /**\n       * See developers.google.com/maps/documentation/javascript/reference/polygon#Polygon.dragend\n       */\n\n      this.polygonDragend = this._eventManager.getLazyEmitter('dragend');\n      /**\n       * See developers.google.com/maps/documentation/javascript/reference/polygon#Polygon.dragstart\n       */\n\n      this.polygonDragstart = this._eventManager.getLazyEmitter('dragstart');\n      /**\n       * See developers.google.com/maps/documentation/javascript/reference/polygon#Polygon.mousedown\n       */\n\n      this.polygonMousedown = this._eventManager.getLazyEmitter('mousedown');\n      /**\n       * See developers.google.com/maps/documentation/javascript/reference/polygon#Polygon.mousemove\n       */\n\n      this.polygonMousemove = this._eventManager.getLazyEmitter('mousemove');\n      /**\n       * See developers.google.com/maps/documentation/javascript/reference/polygon#Polygon.mouseout\n       */\n\n      this.polygonMouseout = this._eventManager.getLazyEmitter('mouseout');\n      /**\n       * See developers.google.com/maps/documentation/javascript/reference/polygon#Polygon.mouseover\n       */\n\n      this.polygonMouseover = this._eventManager.getLazyEmitter('mouseover');\n      /**\n       * See developers.google.com/maps/documentation/javascript/reference/polygon#Polygon.mouseup\n       */\n\n      this.polygonMouseup = this._eventManager.getLazyEmitter('mouseup');\n      /**\n       * See developers.google.com/maps/documentation/javascript/reference/polygon#Polygon.rightclick\n       */\n\n      this.polygonRightclick = this._eventManager.getLazyEmitter('rightclick');\n    }\n\n    _createClass(MapPolygon, [{\n      key: \"options\",\n      set: function set(options) {\n        this._options.next(options || {});\n      }\n    }, {\n      key: \"paths\",\n      set: function set(paths) {\n        this._paths.next(paths);\n      }\n    }, {\n      key: \"ngOnInit\",\n      value: function ngOnInit() {\n        var _this23 = this;\n\n        if (this._map._isBrowser) {\n          this._combineOptions().pipe(take(1)).subscribe(function (options) {\n            // Create the object outside the zone so its events don't trigger change detection.\n            // We'll bring it back in inside the `MapEventManager` only for the events that the\n            // user has subscribed to.\n            _this23._ngZone.runOutsideAngular(function () {\n              _this23.polygon = new google.maps.Polygon(options);\n            });\n\n            _this23._assertInitialized();\n\n            _this23.polygon.setMap(_this23._map.googleMap);\n\n            _this23._eventManager.setTarget(_this23.polygon);\n          });\n\n          this._watchForOptionsChanges();\n\n          this._watchForPathChanges();\n        }\n      }\n    }, {\n      key: \"ngOnDestroy\",\n      value: function ngOnDestroy() {\n        this._eventManager.destroy();\n\n        this._destroyed.next();\n\n        this._destroyed.complete();\n\n        if (this.polygon) {\n          this.polygon.setMap(null);\n        }\n      }\n      /**\n       * See\n       * developers.google.com/maps/documentation/javascript/reference/polygon#Polygon.getDraggable\n       */\n\n    }, {\n      key: \"getDraggable\",\n      value: function getDraggable() {\n        this._assertInitialized();\n\n        return this.polygon.getDraggable();\n      }\n      /**\n       * See developers.google.com/maps/documentation/javascript/reference/polygon#Polygon.getEditable\n       */\n\n    }, {\n      key: \"getEditable\",\n      value: function getEditable() {\n        this._assertInitialized();\n\n        return this.polygon.getEditable();\n      }\n      /**\n       * See developers.google.com/maps/documentation/javascript/reference/polygon#Polygon.getPath\n       */\n\n    }, {\n      key: \"getPath\",\n      value: function getPath() {\n        this._assertInitialized();\n\n        return this.polygon.getPath();\n      }\n      /**\n       * See developers.google.com/maps/documentation/javascript/reference/polygon#Polygon.getPaths\n       */\n\n    }, {\n      key: \"getPaths\",\n      value: function getPaths() {\n        this._assertInitialized();\n\n        return this.polygon.getPaths();\n      }\n      /**\n       * See developers.google.com/maps/documentation/javascript/reference/polygon#Polygon.getVisible\n       */\n\n    }, {\n      key: \"getVisible\",\n      value: function getVisible() {\n        this._assertInitialized();\n\n        return this.polygon.getVisible();\n      }\n    }, {\n      key: \"_combineOptions\",\n      value: function _combineOptions() {\n        return combineLatest([this._options, this._paths]).pipe(map(function (_ref7) {\n          var _ref8 = _slicedToArray(_ref7, 2),\n              options = _ref8[0],\n              paths = _ref8[1];\n\n          var combinedOptions = Object.assign(Object.assign({}, options), {\n            paths: paths || options.paths\n          });\n          return combinedOptions;\n        }));\n      }\n    }, {\n      key: \"_watchForOptionsChanges\",\n      value: function _watchForOptionsChanges() {\n        var _this24 = this;\n\n        this._options.pipe(takeUntil(this._destroyed)).subscribe(function (options) {\n          _this24._assertInitialized();\n\n          _this24.polygon.setOptions(options);\n        });\n      }\n    }, {\n      key: \"_watchForPathChanges\",\n      value: function _watchForPathChanges() {\n        var _this25 = this;\n\n        this._paths.pipe(takeUntil(this._destroyed)).subscribe(function (paths) {\n          if (paths) {\n            _this25._assertInitialized();\n\n            _this25.polygon.setPaths(paths);\n          }\n        });\n      }\n    }, {\n      key: \"_assertInitialized\",\n      value: function _assertInitialized() {\n        if (typeof ngDevMode === 'undefined' || ngDevMode) {\n          if (!this._map.googleMap) {\n            throw Error('Cannot access Google Map information before the API has been initialized. ' + 'Please wait for the API to load before trying to interact with it.');\n          }\n\n          if (!this.polygon) {\n            throw Error('Cannot interact with a Google Map Polygon before it has been ' + 'initialized. Please wait for the Polygon to load before trying to interact with it.');\n          }\n        }\n      }\n    }]);\n\n    return MapPolygon;\n  }();\n\n  MapPolygon.ɵfac = function MapPolygon_Factory(t) {\n    return new (t || MapPolygon)(i0.ɵɵdirectiveInject(GoogleMap), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n\n  MapPolygon.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: MapPolygon,\n    selectors: [[\"map-polygon\"]],\n    inputs: {\n      options: \"options\",\n      paths: \"paths\"\n    },\n    outputs: {\n      polygonClick: \"polygonClick\",\n      polygonDblclick: \"polygonDblclick\",\n      polygonDrag: \"polygonDrag\",\n      polygonDragend: \"polygonDragend\",\n      polygonDragstart: \"polygonDragstart\",\n      polygonMousedown: \"polygonMousedown\",\n      polygonMousemove: \"polygonMousemove\",\n      polygonMouseout: \"polygonMouseout\",\n      polygonMouseover: \"polygonMouseover\",\n      polygonMouseup: \"polygonMouseup\",\n      polygonRightclick: \"polygonRightclick\"\n    },\n    exportAs: [\"mapPolygon\"]\n  });\n  return MapPolygon;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})(); /// <reference types=\"google.maps\" />\n\n/**\n * Angular component that renders a Google Maps Polyline via the Google Maps JavaScript API.\n *\n * See developers.google.com/maps/documentation/javascript/reference/polygon#Polyline\n */\n\n\nvar MapPolyline = /*#__PURE__*/(function () {\n  var MapPolyline = /*#__PURE__*/function () {\n    function MapPolyline(_map, _ngZone) {\n      _classCallCheck(this, MapPolyline);\n\n      this._map = _map;\n      this._ngZone = _ngZone;\n      this._eventManager = new MapEventManager(this._ngZone);\n      this._options = new BehaviorSubject({});\n      this._path = new BehaviorSubject(undefined);\n      this._destroyed = new Subject();\n      /**\n       * See developers.google.com/maps/documentation/javascript/reference/polygon#Polyline.click\n       */\n\n      this.polylineClick = this._eventManager.getLazyEmitter('click');\n      /**\n       * See developers.google.com/maps/documentation/javascript/reference/polygon#Polyline.dblclick\n       */\n\n      this.polylineDblclick = this._eventManager.getLazyEmitter('dblclick');\n      /**\n       * See developers.google.com/maps/documentation/javascript/reference/polygon#Polyline.drag\n       */\n\n      this.polylineDrag = this._eventManager.getLazyEmitter('drag');\n      /**\n       * See developers.google.com/maps/documentation/javascript/reference/polygon#Polyline.dragend\n       */\n\n      this.polylineDragend = this._eventManager.getLazyEmitter('dragend');\n      /**\n       * See developers.google.com/maps/documentation/javascript/reference/polygon#Polyline.dragstart\n       */\n\n      this.polylineDragstart = this._eventManager.getLazyEmitter('dragstart');\n      /**\n       * See developers.google.com/maps/documentation/javascript/reference/polygon#Polyline.mousedown\n       */\n\n      this.polylineMousedown = this._eventManager.getLazyEmitter('mousedown');\n      /**\n       * See developers.google.com/maps/documentation/javascript/reference/polygon#Polyline.mousemove\n       */\n\n      this.polylineMousemove = this._eventManager.getLazyEmitter('mousemove');\n      /**\n       * See developers.google.com/maps/documentation/javascript/reference/polygon#Polyline.mouseout\n       */\n\n      this.polylineMouseout = this._eventManager.getLazyEmitter('mouseout');\n      /**\n       * See developers.google.com/maps/documentation/javascript/reference/polygon#Polyline.mouseover\n       */\n\n      this.polylineMouseover = this._eventManager.getLazyEmitter('mouseover');\n      /**\n       * See developers.google.com/maps/documentation/javascript/reference/polygon#Polyline.mouseup\n       */\n\n      this.polylineMouseup = this._eventManager.getLazyEmitter('mouseup');\n      /**\n       * See developers.google.com/maps/documentation/javascript/reference/polygon#Polyline.rightclick\n       */\n\n      this.polylineRightclick = this._eventManager.getLazyEmitter('rightclick');\n    }\n\n    _createClass(MapPolyline, [{\n      key: \"options\",\n      set: function set(options) {\n        this._options.next(options || {});\n      }\n    }, {\n      key: \"path\",\n      set: function set(path) {\n        this._path.next(path);\n      }\n    }, {\n      key: \"ngOnInit\",\n      value: function ngOnInit() {\n        var _this26 = this;\n\n        if (this._map._isBrowser) {\n          this._combineOptions().pipe(take(1)).subscribe(function (options) {\n            // Create the object outside the zone so its events don't trigger change detection.\n            // We'll bring it back in inside the `MapEventManager` only for the events that the\n            // user has subscribed to.\n            _this26._ngZone.runOutsideAngular(function () {\n              return _this26.polyline = new google.maps.Polyline(options);\n            });\n\n            _this26._assertInitialized();\n\n            _this26.polyline.setMap(_this26._map.googleMap);\n\n            _this26._eventManager.setTarget(_this26.polyline);\n          });\n\n          this._watchForOptionsChanges();\n\n          this._watchForPathChanges();\n        }\n      }\n    }, {\n      key: \"ngOnDestroy\",\n      value: function ngOnDestroy() {\n        this._eventManager.destroy();\n\n        this._destroyed.next();\n\n        this._destroyed.complete();\n\n        if (this.polyline) {\n          this.polyline.setMap(null);\n        }\n      }\n      /**\n       * See\n       * developers.google.com/maps/documentation/javascript/reference/polygon#Polyline.getDraggable\n       */\n\n    }, {\n      key: \"getDraggable\",\n      value: function getDraggable() {\n        this._assertInitialized();\n\n        return this.polyline.getDraggable();\n      }\n      /**\n       * See developers.google.com/maps/documentation/javascript/reference/polygon#Polyline.getEditable\n       */\n\n    }, {\n      key: \"getEditable\",\n      value: function getEditable() {\n        this._assertInitialized();\n\n        return this.polyline.getEditable();\n      }\n      /**\n       * See developers.google.com/maps/documentation/javascript/reference/polygon#Polyline.getPath\n       */\n\n    }, {\n      key: \"getPath\",\n      value: function getPath() {\n        this._assertInitialized();\n\n        return this.polyline.getPath();\n      }\n      /**\n       * See developers.google.com/maps/documentation/javascript/reference/polygon#Polyline.getVisible\n       */\n\n    }, {\n      key: \"getVisible\",\n      value: function getVisible() {\n        this._assertInitialized();\n\n        return this.polyline.getVisible();\n      }\n    }, {\n      key: \"_combineOptions\",\n      value: function _combineOptions() {\n        return combineLatest([this._options, this._path]).pipe(map(function (_ref9) {\n          var _ref10 = _slicedToArray(_ref9, 2),\n              options = _ref10[0],\n              path = _ref10[1];\n\n          var combinedOptions = Object.assign(Object.assign({}, options), {\n            path: path || options.path\n          });\n          return combinedOptions;\n        }));\n      }\n    }, {\n      key: \"_watchForOptionsChanges\",\n      value: function _watchForOptionsChanges() {\n        var _this27 = this;\n\n        this._options.pipe(takeUntil(this._destroyed)).subscribe(function (options) {\n          _this27._assertInitialized();\n\n          _this27.polyline.setOptions(options);\n        });\n      }\n    }, {\n      key: \"_watchForPathChanges\",\n      value: function _watchForPathChanges() {\n        var _this28 = this;\n\n        this._path.pipe(takeUntil(this._destroyed)).subscribe(function (path) {\n          if (path) {\n            _this28._assertInitialized();\n\n            _this28.polyline.setPath(path);\n          }\n        });\n      }\n    }, {\n      key: \"_assertInitialized\",\n      value: function _assertInitialized() {\n        if (typeof ngDevMode === 'undefined' || ngDevMode) {\n          if (!this._map.googleMap) {\n            throw Error('Cannot access Google Map information before the API has been initialized. ' + 'Please wait for the API to load before trying to interact with it.');\n          }\n\n          if (!this.polyline) {\n            throw Error('Cannot interact with a Google Map Polyline before it has been ' + 'initialized. Please wait for the Polyline to load before trying to interact with it.');\n          }\n        }\n      }\n    }]);\n\n    return MapPolyline;\n  }();\n\n  MapPolyline.ɵfac = function MapPolyline_Factory(t) {\n    return new (t || MapPolyline)(i0.ɵɵdirectiveInject(GoogleMap), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n\n  MapPolyline.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: MapPolyline,\n    selectors: [[\"map-polyline\"]],\n    inputs: {\n      options: \"options\",\n      path: \"path\"\n    },\n    outputs: {\n      polylineClick: \"polylineClick\",\n      polylineDblclick: \"polylineDblclick\",\n      polylineDrag: \"polylineDrag\",\n      polylineDragend: \"polylineDragend\",\n      polylineDragstart: \"polylineDragstart\",\n      polylineMousedown: \"polylineMousedown\",\n      polylineMousemove: \"polylineMousemove\",\n      polylineMouseout: \"polylineMouseout\",\n      polylineMouseover: \"polylineMouseover\",\n      polylineMouseup: \"polylineMouseup\",\n      polylineRightclick: \"polylineRightclick\"\n    },\n    exportAs: [\"mapPolyline\"]\n  });\n  return MapPolyline;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})(); /// <reference types=\"google.maps\" />\n\n/**\n * Angular component that renders a Google Maps Rectangle via the Google Maps JavaScript API.\n *\n * See developers.google.com/maps/documentation/javascript/reference/polygon#Rectangle\n */\n\n\nvar MapRectangle = /*#__PURE__*/(function () {\n  var MapRectangle = /*#__PURE__*/function () {\n    function MapRectangle(_map, _ngZone) {\n      _classCallCheck(this, MapRectangle);\n\n      this._map = _map;\n      this._ngZone = _ngZone;\n      this._eventManager = new MapEventManager(this._ngZone);\n      this._options = new BehaviorSubject({});\n      this._bounds = new BehaviorSubject(undefined);\n      this._destroyed = new Subject();\n      /**\n       * See\n       * developers.google.com/maps/documentation/javascript/reference/polygon#Rectangle.boundsChanged\n       */\n\n      this.boundsChanged = this._eventManager.getLazyEmitter('bounds_changed');\n      /**\n       * See\n       * developers.google.com/maps/documentation/javascript/reference/polygon#Rectangle.click\n       */\n\n      this.rectangleClick = this._eventManager.getLazyEmitter('click');\n      /**\n       * See\n       * developers.google.com/maps/documentation/javascript/reference/polygon#Rectangle.dblclick\n       */\n\n      this.rectangleDblclick = this._eventManager.getLazyEmitter('dblclick');\n      /**\n       * See\n       * developers.google.com/maps/documentation/javascript/reference/polygon#Rectangle.drag\n       */\n\n      this.rectangleDrag = this._eventManager.getLazyEmitter('drag');\n      /**\n       * See\n       * developers.google.com/maps/documentation/javascript/reference/polygon#Rectangle.dragend\n       */\n\n      this.rectangleDragend = this._eventManager.getLazyEmitter('dragend');\n      /**\n       * See\n       * developers.google.com/maps/documentation/javascript/reference/polygon#Rectangle.dragstart\n       */\n\n      this.rectangleDragstart = this._eventManager.getLazyEmitter('dragstart');\n      /**\n       * See\n       * developers.google.com/maps/documentation/javascript/reference/polygon#Rectangle.mousedown\n       */\n\n      this.rectangleMousedown = this._eventManager.getLazyEmitter('mousedown');\n      /**\n       * See\n       * developers.google.com/maps/documentation/javascript/reference/polygon#Rectangle.mousemove\n       */\n\n      this.rectangleMousemove = this._eventManager.getLazyEmitter('mousemove');\n      /**\n       * See\n       * developers.google.com/maps/documentation/javascript/reference/polygon#Rectangle.mouseout\n       */\n\n      this.rectangleMouseout = this._eventManager.getLazyEmitter('mouseout');\n      /**\n       * See\n       * developers.google.com/maps/documentation/javascript/reference/polygon#Rectangle.mouseover\n       */\n\n      this.rectangleMouseover = this._eventManager.getLazyEmitter('mouseover');\n      /**\n       * See\n       * developers.google.com/maps/documentation/javascript/reference/polygon#Rectangle.mouseup\n       */\n\n      this.rectangleMouseup = this._eventManager.getLazyEmitter('mouseup');\n      /**\n       * See\n       * developers.google.com/maps/documentation/javascript/reference/polygon#Rectangle.rightclick\n       */\n\n      this.rectangleRightclick = this._eventManager.getLazyEmitter('rightclick');\n    }\n\n    _createClass(MapRectangle, [{\n      key: \"options\",\n      set: function set(options) {\n        this._options.next(options || {});\n      }\n    }, {\n      key: \"bounds\",\n      set: function set(bounds) {\n        this._bounds.next(bounds);\n      }\n    }, {\n      key: \"ngOnInit\",\n      value: function ngOnInit() {\n        var _this29 = this;\n\n        if (this._map._isBrowser) {\n          this._combineOptions().pipe(take(1)).subscribe(function (options) {\n            // Create the object outside the zone so its events don't trigger change detection.\n            // We'll bring it back in inside the `MapEventManager` only for the events that the\n            // user has subscribed to.\n            _this29._ngZone.runOutsideAngular(function () {\n              _this29.rectangle = new google.maps.Rectangle(options);\n            });\n\n            _this29._assertInitialized();\n\n            _this29.rectangle.setMap(_this29._map.googleMap);\n\n            _this29._eventManager.setTarget(_this29.rectangle);\n          });\n\n          this._watchForOptionsChanges();\n\n          this._watchForBoundsChanges();\n        }\n      }\n    }, {\n      key: \"ngOnDestroy\",\n      value: function ngOnDestroy() {\n        this._eventManager.destroy();\n\n        this._destroyed.next();\n\n        this._destroyed.complete();\n\n        if (this.rectangle) {\n          this.rectangle.setMap(null);\n        }\n      }\n      /**\n       * See\n       * developers.google.com/maps/documentation/javascript/reference/polygon#Rectangle.getBounds\n       */\n\n    }, {\n      key: \"getBounds\",\n      value: function getBounds() {\n        this._assertInitialized();\n\n        return this.rectangle.getBounds();\n      }\n      /**\n       * See\n       * developers.google.com/maps/documentation/javascript/reference/polygon#Rectangle.getDraggable\n       */\n\n    }, {\n      key: \"getDraggable\",\n      value: function getDraggable() {\n        this._assertInitialized();\n\n        return this.rectangle.getDraggable();\n      }\n      /**\n       * See\n       * developers.google.com/maps/documentation/javascript/reference/polygon#Rectangle.getEditable\n       */\n\n    }, {\n      key: \"getEditable\",\n      value: function getEditable() {\n        this._assertInitialized();\n\n        return this.rectangle.getEditable();\n      }\n      /**\n       * See\n       * developers.google.com/maps/documentation/javascript/reference/polygon#Rectangle.getVisible\n       */\n\n    }, {\n      key: \"getVisible\",\n      value: function getVisible() {\n        this._assertInitialized();\n\n        return this.rectangle.getVisible();\n      }\n    }, {\n      key: \"_combineOptions\",\n      value: function _combineOptions() {\n        return combineLatest([this._options, this._bounds]).pipe(map(function (_ref11) {\n          var _ref12 = _slicedToArray(_ref11, 2),\n              options = _ref12[0],\n              bounds = _ref12[1];\n\n          var combinedOptions = Object.assign(Object.assign({}, options), {\n            bounds: bounds || options.bounds\n          });\n          return combinedOptions;\n        }));\n      }\n    }, {\n      key: \"_watchForOptionsChanges\",\n      value: function _watchForOptionsChanges() {\n        var _this30 = this;\n\n        this._options.pipe(takeUntil(this._destroyed)).subscribe(function (options) {\n          _this30._assertInitialized();\n\n          _this30.rectangle.setOptions(options);\n        });\n      }\n    }, {\n      key: \"_watchForBoundsChanges\",\n      value: function _watchForBoundsChanges() {\n        var _this31 = this;\n\n        this._bounds.pipe(takeUntil(this._destroyed)).subscribe(function (bounds) {\n          if (bounds) {\n            _this31._assertInitialized();\n\n            _this31.rectangle.setBounds(bounds);\n          }\n        });\n      }\n    }, {\n      key: \"_assertInitialized\",\n      value: function _assertInitialized() {\n        if (typeof ngDevMode === 'undefined' || ngDevMode) {\n          if (!this._map.googleMap) {\n            throw Error('Cannot access Google Map information before the API has been initialized. ' + 'Please wait for the API to load before trying to interact with it.');\n          }\n\n          if (!this.rectangle) {\n            throw Error('Cannot interact with a Google Map Rectangle before it has been initialized. ' + 'Please wait for the Rectangle to load before trying to interact with it.');\n          }\n        }\n      }\n    }]);\n\n    return MapRectangle;\n  }();\n\n  MapRectangle.ɵfac = function MapRectangle_Factory(t) {\n    return new (t || MapRectangle)(i0.ɵɵdirectiveInject(GoogleMap), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n\n  MapRectangle.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: MapRectangle,\n    selectors: [[\"map-rectangle\"]],\n    inputs: {\n      options: \"options\",\n      bounds: \"bounds\"\n    },\n    outputs: {\n      boundsChanged: \"boundsChanged\",\n      rectangleClick: \"rectangleClick\",\n      rectangleDblclick: \"rectangleDblclick\",\n      rectangleDrag: \"rectangleDrag\",\n      rectangleDragend: \"rectangleDragend\",\n      rectangleDragstart: \"rectangleDragstart\",\n      rectangleMousedown: \"rectangleMousedown\",\n      rectangleMousemove: \"rectangleMousemove\",\n      rectangleMouseout: \"rectangleMouseout\",\n      rectangleMouseover: \"rectangleMouseover\",\n      rectangleMouseup: \"rectangleMouseup\",\n      rectangleRightclick: \"rectangleRightclick\"\n    },\n    exportAs: [\"mapRectangle\"]\n  });\n  return MapRectangle;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})(); /// <reference types=\"google.maps\" />\n\n/**\n * Angular component that renders a Google Maps Traffic Layer via the Google Maps JavaScript API.\n *\n * See developers.google.com/maps/documentation/javascript/reference/map#TrafficLayer\n */\n\n\nvar MapTrafficLayer = /*#__PURE__*/(function () {\n  var MapTrafficLayer = /*#__PURE__*/function () {\n    function MapTrafficLayer(_map, _ngZone) {\n      _classCallCheck(this, MapTrafficLayer);\n\n      this._map = _map;\n      this._ngZone = _ngZone;\n      this._autoRefresh = new BehaviorSubject(true);\n      this._destroyed = new Subject();\n    }\n    /**\n     * Whether the traffic layer refreshes with updated information automatically.\n     */\n\n\n    _createClass(MapTrafficLayer, [{\n      key: \"autoRefresh\",\n      set: function set(autoRefresh) {\n        this._autoRefresh.next(autoRefresh);\n      }\n    }, {\n      key: \"ngOnInit\",\n      value: function ngOnInit() {\n        var _this32 = this;\n\n        if (this._map._isBrowser) {\n          this._combineOptions().pipe(take(1)).subscribe(function (options) {\n            // Create the object outside the zone so its events don't trigger change detection.\n            _this32._ngZone.runOutsideAngular(function () {\n              _this32.trafficLayer = new google.maps.TrafficLayer(options);\n            });\n\n            _this32._assertInitialized();\n\n            _this32.trafficLayer.setMap(_this32._map.googleMap);\n          });\n\n          this._watchForAutoRefreshChanges();\n        }\n      }\n    }, {\n      key: \"ngOnDestroy\",\n      value: function ngOnDestroy() {\n        this._destroyed.next();\n\n        this._destroyed.complete();\n\n        if (this.trafficLayer) {\n          this.trafficLayer.setMap(null);\n        }\n      }\n    }, {\n      key: \"_combineOptions\",\n      value: function _combineOptions() {\n        return this._autoRefresh.pipe(map(function (autoRefresh) {\n          var combinedOptions = {\n            autoRefresh: autoRefresh\n          };\n          return combinedOptions;\n        }));\n      }\n    }, {\n      key: \"_watchForAutoRefreshChanges\",\n      value: function _watchForAutoRefreshChanges() {\n        var _this33 = this;\n\n        this._combineOptions().pipe(takeUntil(this._destroyed)).subscribe(function (options) {\n          _this33._assertInitialized();\n\n          _this33.trafficLayer.setOptions(options);\n        });\n      }\n    }, {\n      key: \"_assertInitialized\",\n      value: function _assertInitialized() {\n        if (!this._map.googleMap) {\n          throw Error('Cannot access Google Map information before the API has been initialized. ' + 'Please wait for the API to load before trying to interact with it.');\n        }\n\n        if (!this.trafficLayer) {\n          throw Error('Cannot interact with a Google Map Traffic Layer before it has been initialized. ' + 'Please wait for the Traffic Layer to load before trying to interact with it.');\n        }\n      }\n    }]);\n\n    return MapTrafficLayer;\n  }();\n\n  MapTrafficLayer.ɵfac = function MapTrafficLayer_Factory(t) {\n    return new (t || MapTrafficLayer)(i0.ɵɵdirectiveInject(GoogleMap), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n\n  MapTrafficLayer.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: MapTrafficLayer,\n    selectors: [[\"map-traffic-layer\"]],\n    inputs: {\n      autoRefresh: \"autoRefresh\"\n    },\n    exportAs: [\"mapTrafficLayer\"]\n  });\n  return MapTrafficLayer;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})(); /// <reference types=\"google.maps\" />\n\n/**\n * Angular component that renders a Google Maps Transit Layer via the Google Maps JavaScript API.\n *\n * See developers.google.com/maps/documentation/javascript/reference/map#TransitLayer\n */\n\n\nvar MapTransitLayer = /*#__PURE__*/(function () {\n  var MapTransitLayer = /*#__PURE__*/function (_MapBaseLayer2) {\n    _inherits(MapTransitLayer, _MapBaseLayer2);\n\n    var _super2 = _createSuper(MapTransitLayer);\n\n    function MapTransitLayer() {\n      _classCallCheck(this, MapTransitLayer);\n\n      return _super2.apply(this, arguments);\n    }\n\n    _createClass(MapTransitLayer, [{\n      key: \"_initializeObject\",\n      value: function _initializeObject() {\n        this.transitLayer = new google.maps.TransitLayer();\n      }\n    }, {\n      key: \"_setMap\",\n      value: function _setMap() {\n        this._assertLayerInitialized();\n\n        this.transitLayer.setMap(this._map.googleMap);\n      }\n    }, {\n      key: \"_unsetMap\",\n      value: function _unsetMap() {\n        if (this.transitLayer) {\n          this.transitLayer.setMap(null);\n        }\n      }\n    }, {\n      key: \"_assertLayerInitialized\",\n      value: function _assertLayerInitialized() {\n        if (!this.transitLayer) {\n          throw Error('Cannot interact with a Google Map Transit Layer before it has been initialized. ' + 'Please wait for the Transit Layer to load before trying to interact with it.');\n        }\n      }\n    }]);\n\n    return MapTransitLayer;\n  }(MapBaseLayer);\n\n  MapTransitLayer.ɵfac = /* @__PURE__ */function () {\n    var ɵMapTransitLayer_BaseFactory;\n    return function MapTransitLayer_Factory(t) {\n      return (ɵMapTransitLayer_BaseFactory || (ɵMapTransitLayer_BaseFactory = i0.ɵɵgetInheritedFactory(MapTransitLayer)))(t || MapTransitLayer);\n    };\n  }();\n\n  MapTransitLayer.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: MapTransitLayer,\n    selectors: [[\"map-transit-layer\"]],\n    exportAs: [\"mapTransitLayer\"],\n    features: [i0.ɵɵInheritDefinitionFeature]\n  });\n  return MapTransitLayer;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})(); /// <reference types=\"google.maps\" />\n\n/**\n * Angular directive that renders a Google Maps heatmap via the Google Maps JavaScript API.\n *\n * See: https://developers.google.com/maps/documentation/javascript/reference/visualization\n */\n\n\nvar MapHeatmapLayer = /*#__PURE__*/(function () {\n  var MapHeatmapLayer = /*#__PURE__*/function () {\n    function MapHeatmapLayer(_googleMap, _ngZone) {\n      _classCallCheck(this, MapHeatmapLayer);\n\n      this._googleMap = _googleMap;\n      this._ngZone = _ngZone;\n    }\n    /**\n     * Data shown on the heatmap.\n     * See: https://developers.google.com/maps/documentation/javascript/reference/visualization\n     */\n\n\n    _createClass(MapHeatmapLayer, [{\n      key: \"data\",\n      set: function set(data) {\n        this._data = data;\n      }\n      /**\n       * Options used to configure the heatmap. See:\n       * developers.google.com/maps/documentation/javascript/reference/visualization#HeatmapLayerOptions\n       */\n\n    }, {\n      key: \"options\",\n      set: function set(options) {\n        this._options = options;\n      }\n    }, {\n      key: \"ngOnInit\",\n      value: function ngOnInit() {\n        var _this34 = this;\n\n        var _a, _b;\n\n        if (this._googleMap._isBrowser) {\n          if (!((_b = (_a = window.google) === null || _a === void 0 ? void 0 : _a.maps) === null || _b === void 0 ? void 0 : _b.visualization) && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n            throw Error('Namespace `google.maps.visualization` not found, cannot construct heatmap. ' + 'Please install the Google Maps JavaScript API with the \"visualization\" library: ' + 'https://developers.google.com/maps/documentation/javascript/visualization');\n          } // Create the object outside the zone so its events don't trigger change detection.\n          // We'll bring it back in inside the `MapEventManager` only for the events that the\n          // user has subscribed to.\n\n\n          this._ngZone.runOutsideAngular(function () {\n            _this34.heatmap = new google.maps.visualization.HeatmapLayer(_this34._combineOptions());\n          });\n\n          this._assertInitialized();\n\n          this.heatmap.setMap(this._googleMap.googleMap);\n        }\n      }\n    }, {\n      key: \"ngOnChanges\",\n      value: function ngOnChanges(changes) {\n        var _data = this._data,\n            heatmap = this.heatmap;\n\n        if (heatmap) {\n          if (changes['options']) {\n            heatmap.setOptions(this._combineOptions());\n          }\n\n          if (changes['data'] && _data !== undefined) {\n            heatmap.setData(this._normalizeData(_data));\n          }\n        }\n      }\n    }, {\n      key: \"ngOnDestroy\",\n      value: function ngOnDestroy() {\n        if (this.heatmap) {\n          this.heatmap.setMap(null);\n        }\n      }\n      /**\n       * Gets the data that is currently shown on the heatmap.\n       * See: developers.google.com/maps/documentation/javascript/reference/visualization#HeatmapLayer\n       */\n\n    }, {\n      key: \"getData\",\n      value: function getData() {\n        this._assertInitialized();\n\n        return this.heatmap.getData();\n      }\n      /** Creates a combined options object using the passed-in options and the individual inputs. */\n\n    }, {\n      key: \"_combineOptions\",\n      value: function _combineOptions() {\n        var options = this._options || {};\n        return Object.assign(Object.assign({}, options), {\n          data: this._normalizeData(this._data || options.data || []),\n          map: this._googleMap.googleMap\n        });\n      }\n      /**\n       * Most Google Maps APIs support both `LatLng` objects and `LatLngLiteral`. The latter is more\n       * convenient to write out, because the Google Maps API doesn't have to have been loaded in order\n       * to construct them. The `HeatmapLayer` appears to be an exception that only allows a `LatLng`\n       * object, or it throws a runtime error. Since it's more convenient and we expect that Angular\n       * users will load the API asynchronously, we allow them to pass in a `LatLngLiteral` and we\n       * convert it to a `LatLng` object before passing it off to Google Maps.\n       */\n\n    }, {\n      key: \"_normalizeData\",\n      value: function _normalizeData(data) {\n        var result = [];\n        data.forEach(function (item) {\n          result.push(isLatLngLiteral(item) ? new google.maps.LatLng(item.lat, item.lng) : item);\n        });\n        return result;\n      }\n      /** Asserts that the heatmap object has been initialized. */\n\n    }, {\n      key: \"_assertInitialized\",\n      value: function _assertInitialized() {\n        if (typeof ngDevMode === 'undefined' || ngDevMode) {\n          if (!this._googleMap.googleMap) {\n            throw Error('Cannot access Google Map information before the API has been initialized. ' + 'Please wait for the API to load before trying to interact with it.');\n          }\n\n          if (!this.heatmap) {\n            throw Error('Cannot interact with a Google Map HeatmapLayer before it has been ' + 'initialized. Please wait for the heatmap to load before trying to interact with it.');\n          }\n        }\n      }\n    }]);\n\n    return MapHeatmapLayer;\n  }();\n\n  MapHeatmapLayer.ɵfac = function MapHeatmapLayer_Factory(t) {\n    return new (t || MapHeatmapLayer)(i0.ɵɵdirectiveInject(GoogleMap), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n\n  MapHeatmapLayer.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: MapHeatmapLayer,\n    selectors: [[\"map-heatmap-layer\"]],\n    inputs: {\n      data: \"data\",\n      options: \"options\"\n    },\n    exportAs: [\"mapHeatmapLayer\"],\n    features: [i0.ɵɵNgOnChangesFeature]\n  });\n  return MapHeatmapLayer;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/** Asserts that an object is a `LatLngLiteral`. */\n\n\nfunction isLatLngLiteral(value) {\n  return value && typeof value.lat === 'number' && typeof value.lng === 'number';\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nvar COMPONENTS = [GoogleMap, MapBaseLayer, MapBicyclingLayer, MapCircle, MapDirectionsRenderer, MapGroundOverlay, MapInfoWindow, MapKmlLayer, MapMarker, MapMarkerClusterer, MapPolygon, MapPolyline, MapRectangle, MapTrafficLayer, MapTransitLayer, MapHeatmapLayer];\nvar GoogleMapsModule = /*#__PURE__*/(function () {\n  var GoogleMapsModule = /*#__PURE__*/_createClass(function GoogleMapsModule() {\n    _classCallCheck(this, GoogleMapsModule);\n  });\n\n  GoogleMapsModule.ɵfac = function GoogleMapsModule_Factory(t) {\n    return new (t || GoogleMapsModule)();\n  };\n\n  GoogleMapsModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: GoogleMapsModule\n  });\n  GoogleMapsModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  return GoogleMapsModule;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})(); /// <reference types=\"google.maps\" />\n\n/**\n * Angular service that wraps the Google Maps DirectionsService from the Google Maps JavaScript\n * API.\n *\n * See developers.google.com/maps/documentation/javascript/reference/directions#DirectionsService\n */\n\n\nvar MapDirectionsService = /*#__PURE__*/(function () {\n  var MapDirectionsService = /*#__PURE__*/function () {\n    function MapDirectionsService(_ngZone) {\n      _classCallCheck(this, MapDirectionsService);\n\n      this._ngZone = _ngZone;\n    }\n    /**\n     * See\n     * developers.google.com/maps/documentation/javascript/reference/directions\n     * #DirectionsService.route\n     */\n\n\n    _createClass(MapDirectionsService, [{\n      key: \"route\",\n      value: function route(request) {\n        var _this35 = this;\n\n        return new Observable(function (observer) {\n          // Initialize the `DirectionsService` lazily since the Google Maps API may\n          // not have been loaded when the provider is instantiated.\n          if (!_this35._directionsService) {\n            _this35._directionsService = new google.maps.DirectionsService();\n          }\n\n          _this35._directionsService.route(request, function (result, status) {\n            _this35._ngZone.run(function () {\n              observer.next({\n                result: result || undefined,\n                status: status\n              });\n              observer.complete();\n            });\n          });\n        });\n      }\n    }]);\n\n    return MapDirectionsService;\n  }();\n\n  MapDirectionsService.ɵfac = function MapDirectionsService_Factory(t) {\n    return new (t || MapDirectionsService)(i0.ɵɵinject(i0.NgZone));\n  };\n\n  MapDirectionsService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: MapDirectionsService,\n    factory: MapDirectionsService.ɵfac,\n    providedIn: 'root'\n  });\n  return MapDirectionsService;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})(); /// <reference types=\"google.maps\" />\n\n/**\n * Angular service that wraps the Google Maps Geocoder from the Google Maps JavaScript API.\n * See developers.google.com/maps/documentation/javascript/reference/geocoder#Geocoder\n */\n\n\nvar MapGeocoder = /*#__PURE__*/(function () {\n  var MapGeocoder = /*#__PURE__*/function () {\n    function MapGeocoder(_ngZone) {\n      _classCallCheck(this, MapGeocoder);\n\n      this._ngZone = _ngZone;\n    }\n    /**\n     * See developers.google.com/maps/documentation/javascript/reference/geocoder#Geocoder.geocode\n     */\n\n\n    _createClass(MapGeocoder, [{\n      key: \"geocode\",\n      value: function geocode(request) {\n        var _this36 = this;\n\n        return new Observable(function (observer) {\n          // Initialize the `Geocoder` lazily since the Google Maps API may\n          // not have been loaded when the provider is instantiated.\n          if (!_this36._geocoder) {\n            _this36._geocoder = new google.maps.Geocoder();\n          }\n\n          _this36._geocoder.geocode(request, function (results, status) {\n            _this36._ngZone.run(function () {\n              observer.next({\n                results: results || [],\n                status: status\n              });\n              observer.complete();\n            });\n          });\n        });\n      }\n    }]);\n\n    return MapGeocoder;\n  }();\n\n  MapGeocoder.ɵfac = function MapGeocoder_Factory(t) {\n    return new (t || MapGeocoder)(i0.ɵɵinject(i0.NgZone));\n  };\n\n  MapGeocoder.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: MapGeocoder,\n    factory: MapGeocoder.ɵfac,\n    providedIn: 'root'\n  });\n  return MapGeocoder;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { GoogleMap, GoogleMapsModule, MapBaseLayer, MapBicyclingLayer, MapCircle, MapDirectionsRenderer, MapDirectionsService, MapEventManager, MapGeocoder, MapGroundOverlay, MapHeatmapLayer, MapInfoWindow, MapKmlLayer, MapMarker, MapMarkerClusterer, MapPolygon, MapPolyline, MapRectangle, MapTrafficLayer, MapTransitLayer }; //# sourceMappingURL=google-maps.mjs.map","map":null,"metadata":{},"sourceType":"module"}